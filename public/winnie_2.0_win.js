var app = (function (leaflet) {
	'use strict';

	leaflet = leaflet && leaflet.hasOwnProperty('default') ? leaflet['default'] : leaflet;

	function noop() {}

	function assign(tar, src) {
		for (var k in src) { tar[k] = src[k]; }
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) { tar[k] = 1; }
		return tar;
	}

	function callAfter(fn, i) {
		if (i === 0) { fn(); }
		return function () {
			if (!--i) { fn(); }
		};
	}

	function run(fn) {
		fn();
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function destroyEach(iterations, detach) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) { iterations[i].d(detach); }
		}
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createSvgElement(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function createComment() {
		return document.createComment('');
	}

	function addListener(node, event, handler, options) {
		node.addEventListener(event, handler, options);
	}

	function removeListener(node, event, handler, options) {
		node.removeEventListener(event, handler, options);
	}

	function setAttribute(node, attribute, value) {
		if (value == null) { node.removeAttribute(attribute); }
		else { node.setAttribute(attribute, value); }
	}

	function setData(text, data) {
		text.data = '' + data;
	}

	function setStyle(node, key, value) {
		node.style.setProperty(key, value);
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) { return; }

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				try {
					handler.__calling = true;
					handler.call(this, data);
				} finally {
					handler.__calling = false;
				}
			}
		}
	}

	function flush(component) {
		component._lock = true;
		callAll(component._beforecreate);
		callAll(component._oncreate);
		callAll(component._aftercreate);
		component._lock = false;
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._slots = blankObject();
		component._bind = options._bind;
		component._staged = {};

		component.options = options;
		component.root = options.root || component;
		component.store = options.store || component.root.store;

		if (!options.root) {
			component._beforecreate = [];
			component._oncreate = [];
			component._aftercreate = [];
		}
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) { handlers.splice(index, 1); }
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) { return; }
		flush(this.root);
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		newState = assign(this._staged, newState);
		this._staged = {};

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) { changed[key] = dirty = true; }
		}
		if (!dirty) { return; }

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) { this._bind(changed, this._state); }

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function _stage(newState) {
		assign(this._staged, newState);
	}

	function callAll(fns) {
		while (fns && fns.length) { fns.shift()(); }
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	var proto = {
		destroy: destroy,
		get: get,
		fire: fire,
		on: on,
		set: set,
		_recompute: noop,
		_set: _set,
		_stage: _stage,
		_mount: _mount,
		_differs: _differs
	};

	/* src\LegendIconCell.html generated by Svelte v2.16.0 */

	function backgroundColor(ref) {
		var item = ref.item;

		return L.gmxUtil.dec2rgba(item.RenderStyle.fillColor, item.RenderStyle.fillOpacity || 1);
	}

	function borderColor(ref) {
		var item = ref.item;

		return L.gmxUtil.dec2rgba(item.RenderStyle.color, item.RenderStyle.opacity || 1);
	}

	function data() {
		return {
		}
	}
	function onstate(ref) {
		var changed = ref.changed;
		var current = ref.current;
		var previous = ref.previous;

	 // console.log('LegendIconCell in onstate', changed, current, previous);
	}
	function create_main_fragment(component, ctx) {
		var span, current;

		function select_block_type(ctx) {
			if (ctx.item.RenderStyle.iconUrl) { return create_if_block; }
			return create_else_block;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function c() {
				span = createElement("span");
				if_block.c();
				span.className = "legendIconCell style svelte-14al98j";
			},

			m: function m(target, anchor) {
				insert(target, span, anchor);
				if_block.m(span, null);
				current = true;
			},

			p: function p(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(span, null);
				}
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: run,

			d: function d(detach) {
				if (detach) {
					detachNode(span);
				}

				if_block.d();
			}
		};
	}

	// (4:0) {:else}
	function create_else_block(component, ctx) {
		var span, span_class_value;

		return {
			c: function c() {
				span = createElement("span");
				span.className = span_class_value = "" + ctx.type + " legendIconStyle " + " svelte-14al98j";
				setStyle(span, "background-color", ctx.backgroundColor);
				setStyle(span, "border-color", ctx.borderColor);
			},

			m: function m(target, anchor) {
				insert(target, span, anchor);
			},

			p: function p(changed, ctx) {
				if ((changed.type) && span_class_value !== (span_class_value = "" + ctx.type + " legendIconStyle " + " svelte-14al98j")) {
					span.className = span_class_value;
				}

				if (changed.backgroundColor) {
					setStyle(span, "background-color", ctx.backgroundColor);
				}

				if (changed.borderColor) {
					setStyle(span, "border-color", ctx.borderColor);
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (2:0) {#if item.RenderStyle.iconUrl}
	function create_if_block(component, ctx) {
		var img, img_src_value;

		return {
			c: function c() {
				img = createElement("img");
				img.src = img_src_value = ctx.item.RenderStyle.iconUrl;
				setAttribute(img, "crossorigin", "");
				img.alt = "Style Icon";
				img.className = "svelte-14al98j";
			},

			m: function m(target, anchor) {
				insert(target, img, anchor);
			},

			p: function p(changed, ctx) {
				if ((changed.item) && img_src_value !== (img_src_value = ctx.item.RenderStyle.iconUrl)) {
					img.src = img_src_value;
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(img);
				}
			}
		};
	}

	function LegendIconCell(options) {
		var this$1 = this;

		init(this, options);
		this._state = assign(data(), options.data);

		this._recompute({ item: 1 }, this._state);
		this._intro = !!options.intro;

		this._handlers.state = [onstate];

		onstate.call(this, { changed: assignTrue({}, this._state), current: this._state });

		this._fragment = create_main_fragment(this, this._state);

		this.root._oncreate.push(function () {
			this$1.fire("update", { changed: assignTrue({}, this$1._state), current: this$1._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(LegendIconCell.prototype, proto);

	LegendIconCell.prototype._recompute = function _recompute(changed, state) {
		if (changed.item) {
			if (this._differs(state.backgroundColor, (state.backgroundColor = backgroundColor(state)))) { changed.backgroundColor = true; }
			if (this._differs(state.borderColor, (state.borderColor = borderColor(state)))) { changed.borderColor = true; }
		}
	};

	/* src\LineNode.html generated by Svelte v2.16.0 */

	function checkboxType(ref) {
		var parentProps = ref.parentProps;

		return parentProps && parentProps.list ? 'radio' : 'checkbox';
	}

	function checkboxName(ref) {
		var parentProps = ref.parentProps;

		return parentProps && parentProps.GroupID || '';
	}

	function properties(ref) {
		var line = ref.line;

		return line.content.properties;
	}

	function isRadio(ref) {
		var properties = ref.properties;

		return properties.list ? 'radio' : 'checkbox';
	}

	function nodeID(ref) {
		var properties = ref.properties;

		return properties ? properties.name || properties.GroupID : 'root';
	}

	function styles(ref) {
		var properties = ref.properties;

		return properties.gmxStyles ? properties.gmxStyles.styles : [];
	}

	function multiStyles(ref) {
		var properties = ref.properties;

		return properties.gmxStyles && properties.gmxStyles.styles.length > 1 ? 'multiStyles' : '';
	}

	function isRoot(ref) {
		var properties = ref.properties;

		return properties.MapID;
	}

	function isOpened(ref) {
		var line = ref.line;
		var layersTree = ref.layersTree;

		var content = line.content,
			props = content.properties,
			nodeID = props.GroupID || 'root';
		return layersTree.expanded[nodeID];
	}

	function isGroupVisible(ref) {
		var line = ref.line;
		var layersTree = ref.layersTree;

		var content = line.content,
			props = content.properties,
			nodeID = props.GroupID || 'root';
		return layersTree.visible[nodeID];
	}

	function isVisible(ref) {
		var line = ref.line;
		var layersTree = ref.layersTree;

		return layersTree.visible[line.content.properties.name];
	}

	function data$1() {
		return {
			//gmxTimeline: false,
			line: null
		}
	}
	var methods = {
		clickOnExpander: function clickOnExpander(target) {
			var ref = this.get();
			var line = ref.line;
			
			if (line.type === 'group') {
				var node = this.refs.ul;
				if (node) {
					node.classList[node.classList.contains('collapse') ? 'remove' : 'add']('collapse');
				}
			}
		},
		// toggleVisibility(target) {
			// let {line} = this.get(),
				// node = line.type === 'group' ? this.refs.line.getElementsByClassName('expanderInput')[0] : target;
			
			// if (node) {
				// if (node.checked) {
					// node.checked = false;
					
				// } else {
					// node.checked = true;
				// }
				// if (this.refs.ul) {
					// this.refs.ul.classList[node.checked ? 'remove' : 'add']('collapse');
				// }
			// }
		// },
		toggleTimeline: function toggleTimeline(node) {
			if (node) {
				if (node.classList.contains('disabled')) {
					node.classList.remove('disabled');
					node.classList.add('enabled');
				} else {
					node.classList.add('disabled');
					node.classList.remove('enabled');
				}
			}
		},
		showInfo: function showInfo(target) {
			var node = target.parentNode.nextElementSibling.getElementsByClassName('description')[0];
			if (node) {
				if (node.classList.contains('collapse')) {
					var ref = this.get();
					var line = ref.line;
					node.innerHTML = line.content.properties.description || '';
					node.classList.remove('collapse');
				} else {
					node.classList.add('collapse');
				}
			}
		}
	};

	function get_each_context_1(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.child = list[i];
		return child_ctx;
	}

	function get_each_context(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.it = list[i];
		return child_ctx;
	}

	function create_main_fragment$1(component, ctx) {
		var li, div, text, li_class_value, current;

		var if_block0 = (ctx.properties) && create_if_block_1(component, ctx);

		var if_block1 = (ctx.line.content.children) && create_if_block$1(component, ctx);

		return {
			c: function c() {
				li = createElement("li");
				div = createElement("div");
				if (if_block0) { if_block0.c(); }
				text = createText("\r\n\r\n");
				if (if_block1) { if_block1.c(); }
				div.className = "mega";
				li.className = li_class_value = "line cmd:toggleIcons id:" + ctx.nodeID + " " + ctx.line.type + " svelte-1ohttkn";
			},

			m: function m(target, anchor) {
				insert(target, li, anchor);
				append(li, div);
				if (if_block0) { if_block0.m(div, null); }
				append(li, text);
				if (if_block1) { if_block1.m(li, null); }
				component.refs.line = li;
				current = true;
			},

			p: function p(changed, ctx) {
				if (ctx.properties) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_1(component, ctx);
						if (if_block0) { if_block0.c(); }
					}

					if_block0.i(div, null);
				} else if (if_block0) {
					if_block0.o(function() {
						if_block0.d(1);
						if_block0 = null;
					});
				}

				if (ctx.line.content.children) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block$1(component, ctx);
						if (if_block1) { if_block1.c(); }
					}

					if_block1.i(li, null);
				} else if (if_block1) {
					if_block1.o(function() {
						if_block1.d(1);
						if_block1 = null;
					});
				}

				if ((!current || changed.nodeID || changed.line) && li_class_value !== (li_class_value = "line cmd:toggleIcons id:" + ctx.nodeID + " " + ctx.line.type + " svelte-1ohttkn")) {
					li.className = li_class_value;
				}
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				outrocallback = callAfter(outrocallback, 2);

				if (if_block0) { if_block0.o(outrocallback); }
				else { outrocallback(); }

				if (if_block1) { if_block1.o(outrocallback); }
				else { outrocallback(); }

				current = false;
			},

			d: function d(detach) {
				if (detach) {
					detachNode(li);
				}

				if (if_block0) { if_block0.d(); }
				if (if_block1) { if_block1.d(); }
				if (component.refs.line === li) { component.refs.line = null; }
			}
		};
	}

	// (3:0) {#if properties}
	function create_if_block_1(component, ctx) {
		var text, if_block1_anchor, current;

		var if_block0 = (ctx.line.type !== 'map') && create_if_block_8(component, ctx);

		var if_block1 = (ctx.line.type !== 'map') && create_if_block_2(component, ctx);

		return {
			c: function c() {
				if (if_block0) { if_block0.c(); }
				text = createText("\r\n ");
				if (if_block1) { if_block1.c(); }
				if_block1_anchor = createComment();
			},

			m: function m(target, anchor) {
				if (if_block0) { if_block0.m(target, anchor); }
				insert(target, text, anchor);
				if (if_block1) { if_block1.m(target, anchor); }
				insert(target, if_block1_anchor, anchor);
				current = true;
			},

			p: function p(changed, ctx) {
				if (ctx.line.type !== 'map') {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_8(component, ctx);
						if_block0.c();
						if_block0.m(text.parentNode, text);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.line.type !== 'map') {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_2(component, ctx);
						if (if_block1) { if_block1.c(); }
					}

					if_block1.i(if_block1_anchor.parentNode, if_block1_anchor);
				} else if (if_block1) {
					if_block1.o(function() {
						if_block1.d(1);
						if_block1 = null;
					});
				}
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				if (if_block1) { if_block1.o(outrocallback); }
				else { outrocallback(); }

				current = false;
			},

			d: function d(detach) {
				if (if_block0) { if_block0.d(detach); }
				if (detach) {
					detachNode(text);
				}

				if (if_block1) { if_block1.d(detach); }
				if (detach) {
					detachNode(if_block1_anchor);
				}
			}
		};
	}

	// (4:1) {#if line.type !== 'map'}
	function create_if_block_8(component, ctx) {
		var text, if_block1_anchor;

		var if_block0 = (ctx.line.type === 'group') && create_if_block_13(component, ctx);

		var if_block1 = (ctx.line.type === 'layer') && create_if_block_9(component, ctx);

		return {
			c: function c() {
				if (if_block0) { if_block0.c(); }
				text = createText("\r\n\t\t");
				if (if_block1) { if_block1.c(); }
				if_block1_anchor = createComment();
			},

			m: function m(target, anchor) {
				if (if_block0) { if_block0.m(target, anchor); }
				insert(target, text, anchor);
				if (if_block1) { if_block1.m(target, anchor); }
				insert(target, if_block1_anchor, anchor);
			},

			p: function p(changed, ctx) {
				if (ctx.line.type === 'group') {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_13(component, ctx);
						if_block0.c();
						if_block0.m(text.parentNode, text);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.line.type === 'layer') {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_9(component, ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},

			d: function d(detach) {
				if (if_block0) { if_block0.d(detach); }
				if (detach) {
					detachNode(text);
				}

				if (if_block1) { if_block1.d(detach); }
				if (detach) {
					detachNode(if_block1_anchor);
				}
			}
		};
	}

	// (5:1) {#if line.type === 'group'}
	function create_if_block_13(component, ctx) {
		var input, text, span;

		function click_handler(event) {
			component.clickOnExpander(this);
		}

		return {
			c: function c() {
				input = createElement("input");
				text = createText("\r\n\t");
				span = createElement("span");
				input.className = "expander expanderInput hidden svelte-1ohttkn";
				setAttribute(input, "type", "checkbox");
				input.checked = ctx.isOpened;
				addListener(span, "click", click_handler);
				span.className = "expander pointer expanderCont cmd:clickOnExpander svelte-1ohttkn";
			},

			m: function m(target, anchor) {
				insert(target, input, anchor);
				insert(target, text, anchor);
				insert(target, span, anchor);
			},

			p: function p(changed, ctx) {
				if (changed.isOpened) {
					input.checked = ctx.isOpened;
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(input);
					detachNode(text);
					detachNode(span);
				}

				removeListener(span, "click", click_handler);
			}
		};
	}

	// (9:2) {#if line.type === 'layer'}
	function create_if_block_9(component, ctx) {
		var text0, span1, text1, span0, text2;

		var if_block0 = (ctx.properties.styles.length > 1) && create_if_block_12(component, ctx);

		var if_block1 = (ctx.properties.description) && create_if_block_11(component, ctx);

		var if_block2 = (ctx.gmxTimeline && ctx.properties.Temporal && (ctx.properties.IsRasterCatalog || (ctx.properties.Quicklook && ctx.properties.Quicklook !== 'null'))) && create_if_block_10(component, ctx);

		return {
			c: function c() {
				if (if_block0) { if_block0.c(); }
				text0 = createText("\r\n\t");
				span1 = createElement("span");
				if (if_block1) { if_block1.c(); }
				text1 = createText("\r\n \t\t");
				span0 = createElement("span");
				span0.innerHTML = "<svg role=\"img\" class=\"svgIcon svelte-1ohttkn\"><use xlink:href=\"#center-on-click\" href=\"#center-on-click\"></use></svg>";
				text2 = createText("\r\n\t\t\t\r\n\t\t");
				if (if_block2) { if_block2.c(); }
				span0.className = "pointer cmd:fitBounds cont-center svelte-1ohttkn";
				span0.title = "Move map to this layer";
				span1.className = "icons  svelte-1ohttkn";
			},

			m: function m(target, anchor) {
				if (if_block0) { if_block0.m(target, anchor); }
				insert(target, text0, anchor);
				insert(target, span1, anchor);
				if (if_block1) { if_block1.m(span1, null); }
				append(span1, text1);
				append(span1, span0);
				append(span1, text2);
				if (if_block2) { if_block2.m(span1, null); }
			},

			p: function p(changed, ctx) {
				if (ctx.properties.styles.length > 1) {
					if (!if_block0) {
						if_block0 = create_if_block_12(component, ctx);
						if_block0.c();
						if_block0.m(text0.parentNode, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.properties.description) {
					if (!if_block1) {
						if_block1 = create_if_block_11(component, ctx);
						if_block1.c();
						if_block1.m(span1, text1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.gmxTimeline && ctx.properties.Temporal && (ctx.properties.IsRasterCatalog || (ctx.properties.Quicklook && ctx.properties.Quicklook !== 'null'))) {
					if (!if_block2) {
						if_block2 = create_if_block_10(component, ctx);
						if_block2.c();
						if_block2.m(span1, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},

			d: function d(detach) {
				if (if_block0) { if_block0.d(detach); }
				if (detach) {
					detachNode(text0);
					detachNode(span1);
				}

				if (if_block1) { if_block1.d(); }
				if (if_block2) { if_block2.d(); }
			}
		};
	}

	// (10:3) {#if properties.styles.length > 1}
	function create_if_block_12(component, ctx) {
		var span;

		return {
			c: function c() {
				span = createElement("span");
				span.innerHTML = "<svg role=\"img\" class=\"svgIcon svelte-1ohttkn\"><use xlink:href=\"#overlays\" href=\"#overlays\"></use></svg>";
				span.className = "cont-overlays svelte-1ohttkn";
			},

			m: function m(target, anchor) {
				insert(target, span, anchor);
			},

			d: function d(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (14:2) {#if properties.description}
	function create_if_block_11(component, ctx) {
		var span;

		function click_handler(event) {
			component.showInfo(this, event);
		}

		return {
			c: function c() {
				span = createElement("span");
				span.innerHTML = "<svg role=\"img\" class=\"svgIcon svelte-1ohttkn\"><use xlink:href=\"#info-circle-i\" href=\"#info-circle-i\"></use></svg>";
				addListener(span, "click", click_handler);
				span.className = "pointer cmd:showInfo cont-info svelte-1ohttkn";
				span.title = "View description";
			},

			m: function m(target, anchor) {
				insert(target, span, anchor);
			},

			d: function d(detach) {
				if (detach) {
					detachNode(span);
				}

				removeListener(span, "click", click_handler);
			}
		};
	}

	// (19:2) {#if gmxTimeline && properties.Temporal && (properties.IsRasterCatalog || (properties.Quicklook && properties.Quicklook !== 'null'))}
	function create_if_block_10(component, ctx) {
		var span;

		function click_handler(event) {
			component.toggleTimeline(this);
		}

		return {
			c: function c() {
				span = createElement("span");
				span.innerHTML = "<svg role=\"img\" class=\"svgIcon svelte-1ohttkn\"><use xlink:href=\"#timeline-icon\" href=\"#timeline-icon\"></use></svg>";
				addListener(span, "click", click_handler);
				span.className = "pointer cmd:toggleTimeline timeline disabled svelte-1ohttkn";
				span.title = "Add timeline";
			},

			m: function m(target, anchor) {
				insert(target, span, anchor);
			},

			d: function d(detach) {
				if (detach) {
					detachNode(span);
				}

				removeListener(span, "click", click_handler);
			}
		};
	}

	// (25:1) {#if line.type !== 'map'}
	function create_if_block_2(component, ctx) {
		var span, text0, text1, label, text2_value = ctx.properties.title, text2, label_class_value, text3, div, text4_value = ctx.properties.description || '', text4, div_class_value, text5, current;

		function select_block_type(ctx) {
			if (ctx.line.type === 'group') { return create_if_block_6; }
			return create_else_block$1;
		}

		var current_block_type = select_block_type(ctx);
		var if_block0 = current_block_type(component, ctx);

		var if_block1 = (ctx.line.type === 'layer' && ctx.styles.length && ctx.styles.length < 2 && ctx.styles[0].RenderStyle) && create_if_block_5(component, ctx);

		var if_block2 = (ctx.line.type === 'layer') && create_if_block_3(component, ctx);

		return {
			c: function c() {
				span = createElement("span");
				if_block0.c();
				text0 = createText("\r\n\t\t");
				if (if_block1) { if_block1.c(); }
				text1 = createText("\r\n\t\t");
				label = createElement("label");
				text2 = createText(text2_value);
				text3 = createText("\r\n\t\t");
				div = createElement("div");
				text4 = createText(text4_value);
				text5 = createText("\r\n\t\t");
				if (if_block2) { if_block2.c(); }
				label.className = label_class_value = "pointer title cmd:" + (ctx.line.type === 'group' ? 'toggleGroup' : 'toggleVisibility') + " " + ctx.multiStyles + " svelte-1ohttkn";
				div.className = div_class_value = "description " + (ctx.properties.description ? '' : 'collapse') + " svelte-1ohttkn";
				span.className = "cont";
			},

			m: function m(target, anchor) {
				insert(target, span, anchor);
				if_block0.m(span, null);
				append(span, text0);
				if (if_block1) { if_block1.m(span, null); }
				append(span, text1);
				append(span, label);
				append(label, text2);
				append(span, text3);
				append(span, div);
				append(div, text4);
				append(span, text5);
				if (if_block2) { if_block2.m(span, null); }
				current = true;
			},

			p: function p(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if_block0.d(1);
					if_block0 = current_block_type(component, ctx);
					if_block0.c();
					if_block0.m(span, text0);
				}

				if (ctx.line.type === 'layer' && ctx.styles.length && ctx.styles.length < 2 && ctx.styles[0].RenderStyle) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_5(component, ctx);
						if (if_block1) { if_block1.c(); }
					}

					if_block1.i(span, text1);
				} else if (if_block1) {
					if_block1.o(function() {
						if_block1.d(1);
						if_block1 = null;
					});
				}

				if ((!current || changed.properties) && text2_value !== (text2_value = ctx.properties.title)) {
					setData(text2, text2_value);
				}

				if ((!current || changed.line || changed.multiStyles) && label_class_value !== (label_class_value = "pointer title cmd:" + (ctx.line.type === 'group' ? 'toggleGroup' : 'toggleVisibility') + " " + ctx.multiStyles + " svelte-1ohttkn")) {
					label.className = label_class_value;
				}

				if ((!current || changed.properties) && text4_value !== (text4_value = ctx.properties.description || '')) {
					setData(text4, text4_value);
				}

				if ((!current || changed.properties) && div_class_value !== (div_class_value = "description " + (ctx.properties.description ? '' : 'collapse') + " svelte-1ohttkn")) {
					div.className = div_class_value;
				}

				if (ctx.line.type === 'layer') {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_3(component, ctx);
						if (if_block2) { if_block2.c(); }
					}

					if_block2.i(span, null);
				} else if (if_block2) {
					if_block2.o(function() {
						if_block2.d(1);
						if_block2 = null;
					});
				}
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				outrocallback = callAfter(outrocallback, 2);

				if (if_block1) { if_block1.o(outrocallback); }
				else { outrocallback(); }

				if (if_block2) { if_block2.o(outrocallback); }
				else { outrocallback(); }

				current = false;
			},

			d: function d(detach) {
				if (detach) {
					detachNode(span);
				}

				if_block0.d();
				if (if_block1) { if_block1.d(); }
				if (if_block2) { if_block2.d(); }
			}
		};
	}

	// (31:2) {:else}
	function create_else_block$1(component, ctx) {
		var input, input_class_value;

		return {
			c: function c() {
				input = createElement("input");
				input.className = input_class_value = "check visibility pointer cmd:toggleVisibility " + ctx.line.type + " id:" + ctx.nodeID + " svelte-1ohttkn";
				input.name = ctx.checkboxName;
				setAttribute(input, "type", ctx.checkboxType);
				input.checked = ctx.isVisible;
			},

			m: function m(target, anchor) {
				insert(target, input, anchor);
			},

			p: function p(changed, ctx) {
				if ((changed.line || changed.nodeID) && input_class_value !== (input_class_value = "check visibility pointer cmd:toggleVisibility " + ctx.line.type + " id:" + ctx.nodeID + " svelte-1ohttkn")) {
					input.className = input_class_value;
				}

				if (changed.checkboxName) {
					input.name = ctx.checkboxName;
				}

				if (changed.checkboxType) {
					setAttribute(input, "type", ctx.checkboxType);
				}

				if (changed.isVisible) {
					input.checked = ctx.isVisible;
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(input);
				}
			}
		};
	}

	// (27:2) {#if line.type === 'group'}
	function create_if_block_6(component, ctx) {
		var if_block_anchor;

		var if_block = (ctx.properties.ShowCheckbox) && create_if_block_7(component, ctx);

		return {
			c: function c() {
				if (if_block) { if_block.c(); }
				if_block_anchor = createComment();
			},

			m: function m(target, anchor) {
				if (if_block) { if_block.m(target, anchor); }
				insert(target, if_block_anchor, anchor);
			},

			p: function p(changed, ctx) {
				if (ctx.properties.ShowCheckbox) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_7(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function d(detach) {
				if (if_block) { if_block.d(detach); }
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (28:3) {#if properties.ShowCheckbox}
	function create_if_block_7(component, ctx) {
		var input, input_class_value;

		return {
			c: function c() {
				input = createElement("input");
				input.className = input_class_value = "check visibility pointer cmd:toggleGroup " + ctx.line.type + " id:" + ctx.nodeID + " svelte-1ohttkn";
				input.name = ctx.checkboxName;
				setAttribute(input, "type", ctx.checkboxType);
				input.checked = ctx.isGroupVisible;
			},

			m: function m(target, anchor) {
				insert(target, input, anchor);
			},

			p: function p(changed, ctx) {
				if ((changed.line || changed.nodeID) && input_class_value !== (input_class_value = "check visibility pointer cmd:toggleGroup " + ctx.line.type + " id:" + ctx.nodeID + " svelte-1ohttkn")) {
					input.className = input_class_value;
				}

				if (changed.checkboxName) {
					input.name = ctx.checkboxName;
				}

				if (changed.checkboxType) {
					setAttribute(input, "type", ctx.checkboxType);
				}

				if (changed.isGroupVisible) {
					input.checked = ctx.isGroupVisible;
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(input);
				}
			}
		};
	}

	// (34:2) {#if line.type === 'layer' && styles.length && styles.length < 2 && styles[0].RenderStyle}
	function create_if_block_5(component, ctx) {
		var current;

		var legendiconcell_initial_data = { item: ctx.styles[0], type: ctx.properties.GeometryType };
		var legendiconcell = new LegendIconCell({
			root: component.root,
			store: component.store,
			data: legendiconcell_initial_data
		});

		return {
			c: function c() {
				legendiconcell._fragment.c();
			},

			m: function m(target, anchor) {
				legendiconcell._mount(target, anchor);
				current = true;
			},

			p: function p(changed, ctx) {
				var legendiconcell_changes = {};
				if (changed.styles) { legendiconcell_changes.item = ctx.styles[0]; }
				if (changed.properties) { legendiconcell_changes.type = ctx.properties.GeometryType; }
				legendiconcell._set(legendiconcell_changes);
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				if (legendiconcell) { legendiconcell._fragment.o(outrocallback); }
				current = false;
			},

			d: function d(detach) {
				legendiconcell.destroy(detach);
			}
		};
	}

	// (39:2) {#if line.type === 'layer'}
	function create_if_block_3(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.styles.length && ctx.styles.length > 1 && ctx.styles[0].RenderStyle) && create_if_block_4(component, ctx);

		return {
			c: function c() {
				if (if_block) { if_block.c(); }
				if_block_anchor = createComment();
			},

			m: function m(target, anchor) {
				if (if_block) { if_block.m(target, anchor); }
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function p(changed, ctx) {
				if (ctx.styles.length && ctx.styles.length > 1 && ctx.styles[0].RenderStyle) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_4(component, ctx);
						if (if_block) { if_block.c(); }
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				if (if_block) { if_block.o(outrocallback); }
				else { outrocallback(); }

				current = false;
			},

			d: function d(detach) {
				if (if_block) { if_block.d(detach); }
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (40:3) {#if styles.length && styles.length > 1 && styles[0].RenderStyle}
	function create_if_block_4(component, ctx) {
		var div1, div0, current;

		var each_value = ctx.styles;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block_1(component, get_each_context(ctx, each_value, i));
		}

		function outroBlock(i, detach, fn) {
			if (each_blocks[i]) {
				each_blocks[i].o(function () {
					if (detach) {
						each_blocks[i].d(detach);
						each_blocks[i] = null;
					}
					if (fn) { fn(); }
				});
			}
		}

		return {
			c: function c() {
				div1 = createElement("div");
				div0 = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				div0.className = "legend-cont svelte-1ohttkn";
				div1.className = "legend svelte-1ohttkn";
			},

			m: function m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].i(div0, null);
				}

				current = true;
			},

			p: function p(changed, ctx) {
				if (changed.styles || changed.properties) {
					each_value = ctx.styles;

					for (var i = 0; i < each_value.length; i += 1) {
						var child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_1(component, child_ctx);
							each_blocks[i].c();
						}
						each_blocks[i].i(div0, null);
					}
					for (; i < each_blocks.length; i += 1) { outroBlock(i, 1); }
				}
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				each_blocks = each_blocks.filter(Boolean);
				var countdown = callAfter(outrocallback, each_blocks.length);
				for (var i = 0; i < each_blocks.length; i += 1) { outroBlock(i, 0, countdown); }

				current = false;
			},

			d: function d(detach) {
				if (detach) {
					detachNode(div1);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (43:4) {#each styles as it}
	function create_each_block_1(component, ctx) {
		var div, span0, text0, text1, span1, text2_value = ctx.it.Name, text2, current;

		var legendiconcell_initial_data = { item: ctx.it, type: ctx.properties.GeometryType };
		var legendiconcell = new LegendIconCell({
			root: component.root,
			store: component.store,
			data: legendiconcell_initial_data
		});

		return {
			c: function c() {
				div = createElement("div");
				span0 = createElement("span");
				text0 = createText("\r\n\t\t\t\t\t\t");
				legendiconcell._fragment.c();
				text1 = createText("\r\n\t\t\t\t\t\t");
				span1 = createElement("span");
				text2 = createText(text2_value);
				span0.className = "legendIconEye enabled pointer cmd:toggleStyle svelte-1ohttkn";
				span1.className = "styleName svelte-1ohttkn";
				div.className = "gmx-style-legend svelte-1ohttkn";
			},

			m: function m(target, anchor) {
				insert(target, div, anchor);
				append(div, span0);
				append(div, text0);
				legendiconcell._mount(div, null);
				append(div, text1);
				append(div, span1);
				append(span1, text2);
				current = true;
			},

			p: function p(changed, ctx) {
				var legendiconcell_changes = {};
				if (changed.styles) { legendiconcell_changes.item = ctx.it; }
				if (changed.properties) { legendiconcell_changes.type = ctx.properties.GeometryType; }
				legendiconcell._set(legendiconcell_changes);

				if ((!current || changed.styles) && text2_value !== (text2_value = ctx.it.Name)) {
					setData(text2, text2_value);
				}
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				if (legendiconcell) { legendiconcell._fragment.o(outrocallback); }
				current = false;
			},

			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}

				legendiconcell.destroy();
			}
		};
	}

	// (59:0) {#if line.content.children}
	function create_if_block$1(component, ctx) {
		var ul, ul_class_value, current;

		var each_value_1 = ctx.line.content.children || [];

		var each_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context_1(ctx, each_value_1, i));
		}

		function outroBlock(i, detach, fn) {
			if (each_blocks[i]) {
				each_blocks[i].o(function () {
					if (detach) {
						each_blocks[i].d(detach);
						each_blocks[i] = null;
					}
					if (fn) { fn(); }
				});
			}
		}

		return {
			c: function c() {
				ul = createElement("ul");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				ul.className = ul_class_value = "group css-treeview id_" + ctx.nodeID + " " + (ctx.isOpened || ctx.isRoot ? '' : 'collapse') + " " + ctx.isRadio + " svelte-1ohttkn";
			},

			m: function m(target, anchor) {
				insert(target, ul, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].i(ul, null);
				}

				component.refs.ul = ul;
				current = true;
			},

			p: function p(changed, ctx) {
				if (changed.line || changed.layersTree || changed.gmxTimeline) {
					each_value_1 = ctx.line.content.children || [];

					for (var i = 0; i < each_value_1.length; i += 1) {
						var child_ctx = get_each_context_1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
						}
						each_blocks[i].i(ul, null);
					}
					for (; i < each_blocks.length; i += 1) { outroBlock(i, 1); }
				}

				if ((!current || changed.nodeID || changed.isOpened || changed.isRoot || changed.isRadio) && ul_class_value !== (ul_class_value = "group css-treeview id_" + ctx.nodeID + " " + (ctx.isOpened || ctx.isRoot ? '' : 'collapse') + " " + ctx.isRadio + " svelte-1ohttkn")) {
					ul.className = ul_class_value;
				}
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				each_blocks = each_blocks.filter(Boolean);
				var countdown = callAfter(outrocallback, each_blocks.length);
				for (var i = 0; i < each_blocks.length; i += 1) { outroBlock(i, 0, countdown); }

				current = false;
			},

			d: function d(detach) {
				if (detach) {
					detachNode(ul);
				}

				destroyEach(each_blocks, detach);

				if (component.refs.ul === ul) { component.refs.ul = null; }
			}
		};
	}

	// (61:1) {#each line.content.children || [] as child}
	function create_each_block(component, ctx) {
		var linenode_updating = {}, current;

		var linenode_initial_data = {
		 	line: ctx.child,
		 	parentProps: ctx.line.content.properties
		 };
		if (ctx.layersTree  !== void 0) {
			linenode_initial_data.layersTree = ctx.layersTree ;
			linenode_updating.layersTree = true;
		}
		if (ctx.gmxTimeline  !== void 0) {
			linenode_initial_data.gmxTimeline = ctx.gmxTimeline ;
			linenode_updating.gmxTimeline = true;
		}
		var linenode = new LineNode({
			root: component.root,
			store: component.store,
			data: linenode_initial_data,
			_bind: function _bind(changed, childState) {
				var newState = {};
				if (!linenode_updating.layersTree && changed.layersTree) {
					newState.layersTree = childState.layersTree;
				}

				if (!linenode_updating.gmxTimeline && changed.gmxTimeline) {
					newState.gmxTimeline = childState.gmxTimeline;
				}
				component._set(newState);
				linenode_updating = {};
			}
		});

		component.root._beforecreate.push(function () {
			linenode._bind({ layersTree: 1, gmxTimeline: 1 }, linenode.get());
		});

		return {
			c: function c() {
				linenode._fragment.c();
			},

			m: function m(target, anchor) {
				linenode._mount(target, anchor);
				current = true;
			},

			p: function p(changed, _ctx) {
				ctx = _ctx;
				var linenode_changes = {};
				if (changed.line) { linenode_changes.line = ctx.child; }
				if (changed.line) { linenode_changes.parentProps = ctx.line.content.properties; }
				if (!linenode_updating.layersTree && changed.layersTree) {
					linenode_changes.layersTree = ctx.layersTree ;
					linenode_updating.layersTree = ctx.layersTree  !== void 0;
				}
				if (!linenode_updating.gmxTimeline && changed.gmxTimeline) {
					linenode_changes.gmxTimeline = ctx.gmxTimeline ;
					linenode_updating.gmxTimeline = ctx.gmxTimeline  !== void 0;
				}
				linenode._set(linenode_changes);
				linenode_updating = {};
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				if (linenode) { linenode._fragment.o(outrocallback); }
				current = false;
			},

			d: function d(detach) {
				linenode.destroy(detach);
			}
		};
	}

	function LineNode(options) {
		init(this, options);
		this.refs = {};
		this._state = assign(data$1(), options.data);

		this._recompute({ parentProps: 1, line: 1, properties: 1, layersTree: 1 }, this._state);
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$1(this, this._state);

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(LineNode.prototype, proto);
	assign(LineNode.prototype, methods);

	LineNode.prototype._recompute = function _recompute(changed, state) {
		if (changed.parentProps) {
			if (this._differs(state.checkboxType, (state.checkboxType = checkboxType(state)))) { changed.checkboxType = true; }
			if (this._differs(state.checkboxName, (state.checkboxName = checkboxName(state)))) { changed.checkboxName = true; }
		}

		if (changed.line) {
			if (this._differs(state.properties, (state.properties = properties(state)))) { changed.properties = true; }
		}

		if (changed.properties) {
			if (this._differs(state.isRadio, (state.isRadio = isRadio(state)))) { changed.isRadio = true; }
			if (this._differs(state.nodeID, (state.nodeID = nodeID(state)))) { changed.nodeID = true; }
			if (this._differs(state.styles, (state.styles = styles(state)))) { changed.styles = true; }
			if (this._differs(state.multiStyles, (state.multiStyles = multiStyles(state)))) { changed.multiStyles = true; }
			if (this._differs(state.isRoot, (state.isRoot = isRoot(state)))) { changed.isRoot = true; }
		}

		if (changed.line || changed.layersTree) {
			if (this._differs(state.isOpened, (state.isOpened = isOpened(state)))) { changed.isOpened = true; }
			if (this._differs(state.isGroupVisible, (state.isGroupVisible = isGroupVisible(state)))) { changed.isGroupVisible = true; }
			if (this._differs(state.isVisible, (state.isVisible = isVisible(state)))) { changed.isVisible = true; }
		}
	};

	/* src\TreeView.html generated by Svelte v2.16.0 */

	var regs = {
		cmd: /cmd:(\w+)/,
		id: /id:(\w+)/
	};
	function data$2() {
		return {
			config: {},
			layersTree: {
				visible: {},
				expanded: {}
			},
			//gmxTimeline: false,
			group: null,
			rawTree: null
		}
	}
	var methods$1 = {
		chkEvent: function chkEvent(ev) {
			var target = ev.target,
				className = target.className,
				arr = regs.cmd.exec(className);

			if (arr && arr.length === 2) {
				var out = {
					cmd: arr[1],
					type: ev.type,
					originalEvent: ev
				};
				for(var i = 0; i < 10; i++) {
					if (target.classList.contains('line')) {
						out.nodeType = target.classList.contains('layer') ? 'layer' : 'group';
						out.id = this._getId(target.className);
						out.target = target;
						break;
					}
					target = target.parentNode;
				}
				if (out.id) {
					this.treeCommands(out);
					this.fire('command', out);
				}
			}
		},

		_getId: function _getId(className) {
			var arr = regs.id.exec(className);
			return arr && arr.length === 2 ? arr[1] : '';
		},
		_isExistVisible: function _isExistVisible(node, layersTree) {
			var cnt = 0,
				len = node.children.length; 
			for(var i = 0; i < len; i++) {
				var it = node.children[i],
					id = this._getId(it.className);
				if (layersTree.visible[id]) {
					cnt++;
				}
			}
			return cnt === 0 ? 0 :		// notVisibleLayers
				(cnt === len ? 1 :		// allVisibleLayers
				0.5);					// existsVisibleLayers
		},

		_toggleParents: function _toggleParents(node, visible, layersTree) {
			var flag = true;
			while(flag) {
				node = node.parentNode;
				if (node.classList.contains('line')) {
					var id = this._getId(node.className);
					if (id) {
						layersTree.visible[id] = visible;
					}
				} else if (node.classList.contains('group')) {
					if (!visible && this._isExistVisible(node, layersTree)) {
						flag = false;
					}
				} else {
					flag = false;
				}
			}	},

		_uncheckRadio: function _uncheckRadio(node, id, layersTree) {
			for(var i = 0, len = node.children.length; i < len; i++) {
				var it = node.children[i],
					pid = this._getId(it.className);
				if (pid !== id) {
					this.fire('command', { id: pid, set: false, cmd: 'toggleNode' });
					// layersTree.expanded[pid] = ph.set;
					layersTree.visible[pid] = false;
				}
			}
		},

		_iterateNodeChilds: function _iterateNodeChilds(node, visible, layersTree) {
			var id = this._getId(node.className),
				isGroup = node.classList.contains('group'),
				ul = node.getElementsByTagName('ul')[0];

			layersTree.visible[id] = visible;
			if (isGroup) {
				layersTree.expanded[id] = visible;
			} else {
				this.fire('command', { id: id, set: visible, cmd: 'toggleNode' });
			}
			if (ul) {
				var isRadio = ul.classList.contains('radio'),
					flag = visible;
				for(var i = 0, len = ul.children.length; i < len; i++) {
					var it = ul.children[i],
						pid = this._getId(it.className);
					if (isRadio && i) { flag = false; }
					this._iterateNodeChilds(it, flag, layersTree);
				}
			}
		},

		treeCommands: function treeCommands(attr) {
			var ref = this.get();
			var layersTree = ref.layersTree;
			var rawTree = ref.rawTree;
			var id = attr.id,
				isGroup = attr.nodeType === 'group',
				// expanded = attr.nodeType ? layersTree.expanded : layersTree.visible,
				isExpanded = !layersTree.expanded[id],
				isVisible = !layersTree.visible[id],
				options = layersTree.options[id] || {},
				ph = {
					cmd: 'toggleNode',
					type: attr.type,
					nodeType: attr.nodeType,
					originalEvent: attr.originalEvent
				};

			// console.log('treeCommands', attr.cmd, attr.nodeType);

			if (attr.cmd === 'clickOnExpander') {
				layersTree.expanded[id] = !layersTree.expanded[id];
				this.set({layersTree: layersTree});
			} else if (attr.cmd === 'toggleGroup') {
				this._iterateNodeChilds(attr.target, isVisible, layersTree);
				this._toggleParents(attr.target, isExpanded, layersTree);

				this.set({layersTree: layersTree});
			} else if (attr.cmd === 'toggleVisibility') {
				var node = attr.target,
					isGroup$1 = node.getElementsByClassName('expanderInput')[0],
					expanded = isGroup$1 ? layersTree.expanded : layersTree.visible,
					ul = node.parentNode;

				if (expanded[id]) {
					delete expanded[id];
				} else {
					expanded[id] = true;
				}
				if (ul && ul.classList.contains('radio')) {
					this._uncheckRadio(ul, id, layersTree);
				}
				this._toggleParents(attr.target, expanded[id], layersTree);
				this.set({layersTree: layersTree});
				return true;
			}
			return false;
		},

		appendNode: function appendNode(id) {
			this.options.appendNode(id);
		}
	};

	function create_main_fragment$2(component, ctx) {
		var div, linenode_updating = {}, current;

		var linenode_initial_data = { line: ctx.rawTree, parentProps: ctx.rawTree.content.properties };
		if (ctx.layersTree  !== void 0) {
			linenode_initial_data.layersTree = ctx.layersTree ;
			linenode_updating.layersTree = true;
		}
		if (ctx.gmxTimeline  !== void 0) {
			linenode_initial_data.gmxTimeline = ctx.gmxTimeline ;
			linenode_updating.gmxTimeline = true;
		}
		var linenode = new LineNode({
			root: component.root,
			store: component.store,
			data: linenode_initial_data,
			_bind: function _bind(changed, childState) {
				var newState = {};
				if (!linenode_updating.layersTree && changed.layersTree) {
					newState.layersTree = childState.layersTree;
				}

				if (!linenode_updating.gmxTimeline && changed.gmxTimeline) {
					newState.gmxTimeline = childState.gmxTimeline;
				}
				component._set(newState);
				linenode_updating = {};
			}
		});

		component.root._beforecreate.push(function () {
			linenode._bind({ layersTree: 1, gmxTimeline: 1 }, linenode.get());
		});

		function click_handler(event) {
			component.chkEvent(event);
		}

		return {
			c: function c() {
				div = createElement("div");
				linenode._fragment.c();
				addListener(div, "click", click_handler);
				div.className = "TreeView svelte-829z2l";
			},

			m: function m(target, anchor) {
				insert(target, div, anchor);
				linenode._mount(div, null);
				current = true;
			},

			p: function p(changed, _ctx) {
				ctx = _ctx;
				var linenode_changes = {};
				if (changed.rawTree) { linenode_changes.line = ctx.rawTree; }
				if (changed.rawTree) { linenode_changes.parentProps = ctx.rawTree.content.properties; }
				if (!linenode_updating.layersTree && changed.layersTree) {
					linenode_changes.layersTree = ctx.layersTree ;
					linenode_updating.layersTree = ctx.layersTree  !== void 0;
				}
				if (!linenode_updating.gmxTimeline && changed.gmxTimeline) {
					linenode_changes.gmxTimeline = ctx.gmxTimeline ;
					linenode_updating.gmxTimeline = ctx.gmxTimeline  !== void 0;
				}
				linenode._set(linenode_changes);
				linenode_updating = {};
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				if (linenode) { linenode._fragment.o(outrocallback); }
				current = false;
			},

			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}

				linenode.destroy();
				removeListener(div, "click", click_handler);
			}
		};
	}

	function TreeView(options) {
		init(this, options);
		this._state = assign(data$2(), options.data);
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$2(this, this._state);

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(TreeView.prototype, proto);
	assign(TreeView.prototype, methods$1);

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var EventTarget = function () {
	    function EventTarget() {
	        classCallCheck(this, EventTarget);

	        this.listeners = {};
	    }

	    createClass(EventTarget, [{
	        key: 'addEventListener',
	        value: function addEventListener(type, callback) {
	            if (!(type in this.listeners)) {
	                this.listeners[type] = [];
	            }
	            this.listeners[type].push(callback);
	        }
	    }, {
	        key: 'on',
	        value: function on(type, callback) {
	            this.addEventListener(type, callback);
	            return this;
	        }
	    }, {
	        key: 'removeEventListener',
	        value: function removeEventListener(type, callback) {
	            if (!(type in this.listeners)) {
	                return;
	            }
	            var stack = this.listeners[type];
	            for (var i = 0, l = stack.length; i < l; i++) {
	                if (stack[i] === callback) {
	                    stack.splice(i, 1);
	                    return this.removeEventListener(type, callback);
	                }
	            }
	        }
	    }, {
	        key: 'off',
	        value: function off(type, callback) {
	            this.removeEventListener(type, callback);
	            return this;
	        }
	    }, {
	        key: 'dispatchEvent',
	        value: function dispatchEvent(event) {
	            if (!(event.type in this.listeners)) {
	                return;
	            }
	            var stack = this.listeners[event.type];
	            Object.defineProperty(event, 'target', {
	                enumerable: false,
	                configurable: false,
	                writable: false,
	                value: this
	            });
	            for (var i = 0, l = stack.length; i < l; i++) {
	                stack[i].call(this, event);
	            }
	        }
	    }]);
	    return EventTarget;
	}();

	class Sidebar extends EventTarget {
	    constructor(container, { position = 'left' } = {}) {
	        super();
	        this._container = container;
	        this._container.innerHTML = `<div class="scanex-sidebar">
            <div class="${position === 'left' ? 'tabs' : 'panes'}"></div>
            <div class="${position === 'left' ? 'panes' : 'tabs'}"></div>
        </div>`;

	        this._tabContainer = this._container.querySelector('.tabs');
	        this._paneContainer = this._container.querySelector('.panes');

	        this._current = null;
	        this._data = {};
	    }
	    enable(id) {
	        if (this._data[id]) {
	            this._data[id].enabled = true;
	        }
	    }
	    enabled(id) {
	        const { enabled } = id && this._data[id] ? this._data[id] : { enabled: false };
	        return enabled;
	    }
	    disable(id) {
	        if (this._data[id]) {
	            if (id === this.current) {
	                this.current = null;
	            }
	            this._data[id].enabled = false;
	        }
	    }
	    get current() {
	        return this._current;
	    }
	    set current(current) {
	        const tabs = this._tabContainer.children;
	        const panes = this._paneContainer.children;
	        let success = false;

	        for (let i = 0; i < tabs.length; ++i) {
	            const id = tabs[i].getAttribute('data-tab-id');
	            const { opened, closed, enabled } = this._data[id];
	            let tab = tabs[i].querySelector('i');
	            let pane = panes[i];
	            if (id === current) {
	                tab.classList.remove(closed);
	                tab.classList.add(opened);

	                pane.classList.remove('hidden');
	                pane.classList.add('shown');

	                success = true;
	            } else {
	                tab.classList.remove(opened);
	                tab.classList.add(closed);

	                pane.classList.remove('shown');
	                pane.classList.add('hidden');
	            }
	        }
	        this._current = success ? current : null;
	        let event = document.createEvent('Event');
	        event.detail = { current: this._current };
	        event.initEvent('change', false, false);
	        this.dispatchEvent(event);
	    }
	    addTab({ id, icon, opened, closed, tooltip, enabled = true }) {
	        let tab = document.createElement('div');
	        let ic = document.createElement('i');
	        icon.split(/\s+/g).forEach(x => ic.classList.add(x));
	        ic.classList.add(id === this._current ? opened : closed);
	        tab.appendChild(ic);
	        tab.setAttribute('data-tab-id', id);
	        if (tooltip) {
	            tab.setAttribute('title', tooltip);
	        }
	        tab.addEventListener('click', this._toggle.bind(this, id));
	        this._tabContainer.appendChild(tab);

	        let pane = document.createElement('div');
	        pane.setAttribute('data-pane-id', id);
	        pane.classList.add(this.visible && this.current === id ? 'shown' : 'hidden');
	        this._paneContainer.appendChild(pane);

	        this._data[id] = { icon, opened, closed, enabled };

	        return pane;
	    }
	    removeTab(id) {
	        const tab = this._tabContainer.querySelector(`[data-tab-id=${id}]`);
	        tab.removeEventListener('click', this._toggle.bind(this, id));
	        this._tabContainer.removeChild(tab);

	        const pane = this._paneContainer.querySelector(`[data-pane-id=${id}]`);
	        this._paneContainer.removeChild(pane);

	        for (let i = 0; i < this._data.length; ++i) {
	            if (this._data[i].id === id) {
	                this._data.splice(i, 1);
	                break;
	            }
	        }
	    }
	    _toggle(current) {
	        if (this.enabled(current)) {
	            this.current = this.current === current ? null : current;
	        }
	    }
	    getPane(id) {
	        return this._paneContainer.querySelector(`[data-pane-id=${id}]`);
	    }
	}

	let SidebarControl = L.Control.extend({
	    includes: L.Evented ? L.Evented.prototype : L.Mixin.Events,

	    initialize: function (options) {
	        L.setOptions(this, options);
	    },

	    enable: function (id) {
	        this._sidebar.enable(id);
	    },

	    enabled: function (id) {
	        return this._sidebar.enabled(id);
	    },

	    disable: function (id) {
	        this._sidebar.disable(id);
	    },

	    getCurrent: function () {
	        return this._sidebar.current;
	    },

	    setCurrent: function (current) {
	        this._sidebar.current = current;
	    },

	    addTab: function ({ id, icon, opened, closed, tooltip, enabled }) {
	        return this._sidebar.addTab({ id, icon, opened, closed, tooltip, enabled });
	    },

	    removeTab: function (id) {
	        this._sidebar.removeTab(id);
	    },

	    getPane: function (id) {
	        return this._sidebar.getPane(id);
	    },

	    onAdd: function (map) {
	        this._container = L.DomUtil.create('div');
	        const stop = L.DomEvent.stopPropagation;
	        const fakeStop = L.DomEvent._fakeStop || stop;
	        L.DomEvent.on(this._container, 'contextmenu', stop).on(this._container, 'click', fakeStop).on(this._container, 'mousedown', stop).on(this._container, 'touchstart', stop).on(this._container, 'dblclick', fakeStop).on(this._container, 'mousewheel', stop).on(this._container, 'MozMousePixelScroll', stop);
	        const { position } = this.options;
	        this._sidebar = new Sidebar(this._container, { position: position === 'topleft' || position === 'bottomleft' ? 'left' : 'right' });
	        this._sidebar.addEventListener('change', e => {
	            this.fire('change', e);
	        });
	        return this._container;
	    },

	    addTo: function (map) {
	        L.Control.prototype.addTo.call(this, map);
	        if (this.options.addBefore) {
	            this.addBefore(this.options.addBefore);
	        }
	        return this;
	    },

	    addBefore: function (id) {
	        let parentNode = this._parent && this._parent._container;
	        if (!parentNode) {
	            parentNode = this._map && this._map._controlCorners[this.getPosition()];
	        }
	        if (!parentNode) {
	            this.options.addBefore = id;
	        } else {
	            for (let i = 0, len = parentNode.childNodes.length; i < len; i++) {
	                let it = parentNode.childNodes[i];
	                if (id === it._id) {
	                    parentNode.insertBefore(this._container, it);
	                    break;
	                }
	            }
	        }
	        return this;
	    }
	});

	var scanexLeafletSidebar_cjs = SidebarControl;

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var iconLayers = createCommonjsModule(function (module) {
	/*eslint-env commonjs, browser */
	(function(factory) {
	    if (module.exports) {
	        module.exports = factory(leaflet);
	    } else {
	        window.L.control.iconLayers = factory(window.L);
	        window.L.Control.IconLayers = window.L.control.iconLayers.Constructor;
	    }
	})(function(L) {
	    function each(o, cb) {
	        for (var p in o) {
	            if (o.hasOwnProperty(p)) {
	                cb(o[p], p, o);
	            }
	        }
	    }

	    function find(ar, cb) {
	        if (ar.length) {
	            for (var i = 0; i < ar.length; i++) {
	                if (cb(ar[i])) {
	                    return ar[i];
	                }
	            }
	        } else {
	            for (var p in ar) {
	                if (ar.hasOwnProperty(p) && cb(ar[p])) {
	                    return ar[p];
	                }
	            }
	        }
	    }

	    function first(o) {
	        for (var p in o) {
	            if (o.hasOwnProperty(p)) {
	                return o[p];
	            }
	        }
	    }

	    function length(o) {
	        var length = 0;
	        for (var p in o) {
	            if (o.hasOwnProperty(p)) {
	                length++;
	            }
	        }
	        return length;
	    }

	    function prepend(parent, el) {
	        if (parent.children.length) {
	            parent.insertBefore(el, parent.children[0]);
	        } else {
	            parent.appendChild(el);
	        }
	    }

	    var IconLayers = L.Control.extend({

	        includes: L.Evented ? L.Evented.prototype : L.Mixin.Events,
	        _getActiveLayer: function() {
	            if (this._activeLayerId) {
	                return this._layers[this._activeLayerId];
	            } else if (length(this._layers)) {
	                return first(this._layers);
	            } else {
	                return null;
	            }
	        },
	        _getPreviousLayer: function() {
	            var activeLayer = this._getActiveLayer();
	            if (!activeLayer) {
	                return null;
	            } else if (this._previousLayerId) {
	                return this._layers[this._previousLayerId];
	            } else {
	                return find(this._layers, function(l) {
	                    return l.id !== activeLayer.id;
	                }.bind(this)) || null;
	            }
	        },
	        _getInactiveLayers: function() {
	            var ar = [];
	            var activeLayerId = this._getActiveLayer() ? this._getActiveLayer().id : null;
	            var previousLayerId = this._getPreviousLayer() ? this._getPreviousLayer().id : null;
	            each(this._layers, function(l) {
	                if ((l.id !== activeLayerId) && (l.id !== previousLayerId)) {
	                    ar.push(l);
	                }
	            });
	            return ar;
	        },
	        _arrangeLayers: function() {
	            var behaviors = {};
	            behaviors.previous = function() {
	                var layers = this._getInactiveLayers();
	                if (this._getActiveLayer()) {
	                    layers.unshift(this._getActiveLayer());
	                }
	                if (this._getPreviousLayer()) {
	                    layers.unshift(this._getPreviousLayer());
	                }
	                return layers;
	            };
	            return behaviors[this.options.behavior].apply(this, arguments);
	        },
	        _getLayerCellByLayerId: function(id) {
	            var els = this._container.getElementsByClassName('leaflet-iconLayers-layerCell');
	            for (var i = 0; i < els.length; i++) {
	                if (els[i].getAttribute('data-layerid') == id) {
	                    return els[i];
	                }
	            }
	        },
	        _createLayerElement: function(layerObj) {
	            var el = L.DomUtil.create('div', 'leaflet-iconLayers-layer');
	            if (layerObj.title) {
	                var titleContainerEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerTitleContainer');
	                var titleEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerTitle');
	                var checkIconEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerCheckIcon');
	                titleEl.innerHTML = layerObj.title;
	                titleContainerEl.appendChild(titleEl);
	                el.appendChild(titleContainerEl);
	                el.appendChild(checkIconEl);
	            }
	            if (layerObj.icon) {
	                el.setAttribute('style', 'background-image: url(\'' + layerObj.icon + '\')');
	            }
	            return el;
	        },
	        _createLayerElements: function() {
	            var currentRow, layerCell;
	            var layers = this._arrangeLayers();
	            var activeLayerId = this._getActiveLayer() && this._getActiveLayer().id;

	            for (var i = 0; i < layers.length; i++) {
	                if (i % this.options.maxLayersInRow === 0) {
	                    currentRow = L.DomUtil.create('div', 'leaflet-iconLayers-layersRow');
	                    if (this.options.position.indexOf('bottom') === -1) {
	                        this._container.appendChild(currentRow);
	                    } else {
	                        prepend(this._container, currentRow);
	                    }
	                }
	                layerCell = L.DomUtil.create('div', 'leaflet-iconLayers-layerCell');
	                layerCell.setAttribute('data-layerid', layers[i].id);
	                if (i !== 0) {
	                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_hidden');
	                }
	                if (layers[i].id === activeLayerId) {
	                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_active');
	                }
	                if (this._expandDirection === 'left') {
	                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_expandLeft');
	                } else {
	                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_expandRight');
	                }
	                layerCell.appendChild(this._createLayerElement(layers[i]));

	                if (this.options.position.indexOf('right') === -1) {
	                    currentRow.appendChild(layerCell);
	                } else {
	                    prepend(currentRow, layerCell);
	                }
	            }
	        },
	        _onLayerClick: function(e) {
	            e.stopPropagation();
	            var layerId = e.currentTarget.getAttribute('data-layerid');
	            var layer = this._layers[layerId];
	            this.setActiveLayer(layer.layer);
	            this.expand();
	        },
	        _attachEvents: function() {
	            each(this._layers, function(l) {
	                var e = this._getLayerCellByLayerId(l.id);
	                if (e) {
	                    e.addEventListener('click', this._onLayerClick.bind(this));
	                }
	            }.bind(this));
	            var layersRowCollection = this._container.getElementsByClassName('leaflet-iconLayers-layersRow');

	            var onMouseEnter = function(e) {
	                e.stopPropagation();
	                this.expand();
	            }.bind(this);

	            var onMouseLeave = function(e) {
	                e.stopPropagation();
	                this.collapse();
	            }.bind(this);

	            var stopPropagation = function(e) {
	                e.stopPropagation();
	            };

	            //TODO Don't make functions within a loop.
	            for (var i = 0; i < layersRowCollection.length; i++) {
	                var el = layersRowCollection[i];
	                el.addEventListener('mouseenter', onMouseEnter);
	                el.addEventListener('mouseleave', onMouseLeave);
	                el.addEventListener('mousemove', stopPropagation);
	            }
	        },
	        _render: function() {
	            this._container.innerHTML = '';
	            this._createLayerElements();
	            this._attachEvents();
	        },
	        _switchMapLayers: function() {
	            if (!this._map) {
	                return;
	            }
	            var activeLayer = this._getActiveLayer();
	            var previousLayer = this._getPreviousLayer();
	            if (previousLayer) {
	                this._map.removeLayer(previousLayer.layer);
	            } else {
	                each(this._layers, function(layerObject) {
	                    var layer = layerObject.layer;
	                    this._map.removeLayer(layer);
	                }.bind(this));
	            }
	            if (activeLayer) {
	                this._map.addLayer(activeLayer.layer);
	            }
	        },
	        options: {
	            position: 'bottomleft', // one of expanding directions depends on this
	            behavior: 'previous', // may be 'previous', 'expanded' or 'first'
	            expand: 'horizontal', // or 'vertical'
	            autoZIndex: true, // from L.Control.Layers
	            maxLayersInRow: 5,
	            manageLayers: true
	        },
	        initialize: function(layers, options) {
	            if (!L.Util.isArray(arguments[0])) {
	                // first argument is options
	                options = layers;
	                layers = [];
	            }
	            L.setOptions(this, options);
	            this._expandDirection = (this.options.position.indexOf('left') != -1) ? 'right' : 'left';
	            if (this.options.manageLayers) {
	                this.on('activelayerchange', this._switchMapLayers, this);
	            }
	            this.setLayers(layers);
	        },
	        onAdd: function(map) {
	            this._container = L.DomUtil.create('div', 'leaflet-iconLayers');
	            L.DomUtil.addClass(this._container, 'leaflet-iconLayers_' + this.options.position);
	            this._render();
	            map.on('click', this.collapse, this);
	            if (this.options.manageLayers) {
	                this._switchMapLayers();
	            }
	            return this._container;
	        },
	        onRemove: function(map) {
	            map.off('click', this.collapse, this);
	        },
	        setLayers: function(layers) {
	            this._layers = {};
	            layers.map(function(layer) {
	                var id = L.stamp(layer.layer);
	                this._layers[id] = L.extend(layer, {
	                    id: id
	                });
	            }.bind(this));
	            if (this._container) {
	                this._render();
	            }
	        },
	        setActiveLayer: function(layer) {
	            var l = layer && this._layers[L.stamp(layer)];
	            if (!l || l.id === this._activeLayerId) {
	                return;
	            }
	            this._previousLayerId = this._activeLayerId;
	            this._activeLayerId = l.id;
	            if (this._container) {
	                this._render();
	            }
	            this.fire('activelayerchange', {
	                layer: layer
	            });
	        },
	        expand: function() {
	            this._arrangeLayers().slice(1).map(function(l) {
	                var el = this._getLayerCellByLayerId(l.id);
	                L.DomUtil.removeClass(el, 'leaflet-iconLayers-layerCell_hidden');
	            }.bind(this));
	        },
	        collapse: function() {
	            this._arrangeLayers().slice(1).map(function(l) {
	                var el = this._getLayerCellByLayerId(l.id);
	                L.DomUtil.addClass(el, 'leaflet-iconLayers-layerCell_hidden');
	            }.bind(this));
	        }
	    });

	    var iconLayers = function(layers, options) {
	        return new IconLayers(layers, options);
	    };

	    iconLayers.Constructor = IconLayers;

	    return iconLayers;
	});
	});

	/* src\Map.html generated by Svelte v2.16.0 */




	var serverBase = window.serverBase || '//maps.kosmosnimki.ru/';

	function data$3() {
		return {
			layersTree: {
				options: {},
				visible: {},
				expanded: {}
			},
			permalink: null,
			map: null
		}
	}
	var methods$2 = {
		createMap: function createMap(it) {
			var ref = this.get();
			var layersTree = ref.layersTree;
			var app = it.app || {},
				gmxMap = app.gmxMap || {},
				state = it.state || {},
				// layersTree = state.layersTree || {},
				calendar = state.calendar || {},
				mapID = gmxMap.mapID || '946GH',
				apiKey = gmxMap.apiKey || 'Z2SSNR87N4',
				pos = state.map ? state.map.position : {};

			// console.log('createMap', it)
			if(app.theme) {
				document.body.classList.add(app.theme);
			}
			if(L.leafletMap) {
				L.leafletMap.remove();
			}

			layersTree = state.layersTree || layersTree;
			layersTree.options = layersTree.options || {};
			this.layersTree = layersTree;
			var map = new L.Map('map', {
				srs: 3857,
				layers: [],
				center: new L.LatLng(pos.y || 0, pos.x || 60),
				zoom: pos.z || 3
			});
			L.leafletMap = map;

			map.gmxControlsManager.init({
				gmxDrawing: !app.drawing || app.drawing === 'false' ? null : {position: 'right'},
				gmxZoom: {position: 'gmxbottomright'},
				gmxLoaderStatus: {position: 'gmxbottomright'},
				gmxHide: null
			});
			map.gmxControlsManager.setSvgSprites('//www.kosmosnimki.ru/lib/geomixer_1.3/img/svg-symbols.svg');

			if (app.iconSidebar && app.iconSidebar !== 'false') {
				var iconSidebar = new scanexLeafletSidebar_cjs({position: 'topleft', className: 'sidebarControl'});
				iconSidebar.addTo(map);
				iconSidebar.getContainer().classList.add('sidebarControl');

				this.iconSidebar = iconSidebar;
				if (app.treeView && app.treeView !== 'false') {
					var treePane = iconSidebar.addTab({id: 'treeView', icon: 'icon-layers', opened: 'opened', closed: 'closed'});
					this.treePane = treePane;
				}
			} else {
				document.body.classList.add('noIconSidebar');
			}

			this.mapID = mapID;
			var opt = {
				leafletMap: map,
				apiKey: apiKey,
				// visibleItemOnly: true,	// TODO: только видимые элементы (слои и папки) баги серверного скрипта
				setZIndex: true
				// ,
				// visibility: layersTree.visible || {}
			};
			L.gmx.loadMap(mapID, opt).then(function(gmxMap) {
				var this$1 = this;

				this.gmxMap = gmxMap;
				var dateInterval = state.calendar || {},
					tb = dateInterval.dateBegin,
					te = dateInterval.dateEnd;
				if(!tb) {
					var day = 1000*60*60*24,
						cd = new Date();
					tb = Date.UTC(cd.getUTCFullYear(), cd.getUTCMonth(), cd.getUTCDate());
					te = tb + day;
				}
				var db = new Date(tb), de = new Date(te);
				gmxMap.layers.forEach(function (it) {
					if(it.getGmxProperties) {
						var props = it.getGmxProperties(),
							id = props.name;
						if(it.setDateInterval) {
							it.setDateInterval(db, de);
						}
						if(id in layersTree.visible) {
							map[layersTree.visible[id] ? 'addLayer' : 'removeLayer'](it);
						}
					}
				});
				L.gmx.gmxMapManager.iterateNode(gmxMap.rawTree, function(node, prnt) {
					var props = node.content.properties,
						id = props.name || props.GroupID;
					if (props.GroupID) {
						if (props.expanded && !(id in layersTree.expanded)) {
							layersTree.expanded[id] = props.expanded;
						}
						if (props.visible && !(id in layersTree.visible)) {
							layersTree.visible[id] = props.visible;
						}
					} else {
						if (props.visible && !(id in layersTree.visible)) {
							layersTree.visible[id] = props.visible;
						}
						var prntProps = prnt.properties;
						if (prntProps.GroupID && prntProps.list) {
							var opt = layersTree.options[id] || {};
							opt.list = prntProps.list;
							layersTree.options[id]  = opt;
						}
					}
				}, {nodes: gmxMap.nodes});

				// this.set({layersTree: layersTree}); 
				// this.set({gmxMap: gmxMap}); 
				var shiftIconLayers = false,
					repaintTimeline = null;

				if (app.gmxTimeline && app.gmxTimeline !== 'false') {
					/* TimeLine */
					var control = L.control.gmxTimeline({
						moveable: true
						}).on('dateInterval', function (ev) {
							gmxMap.layersByID[ev.layerID].setDateInterval(ev.beginDate, ev.endDate);
						})
						.on('statechanged', function () {
							repaintTimeline();
						})
						.on('click', function (ev) {
							gmxMap.layersByID[ev.layerID].repaint();
						});
					this.gmxTimeline = control;
					repaintTimeline = function () {
						if (control._container) {
							control._container.classList[shiftIconLayers ? 'add' : 'remove']('shiftTimeline');
							control._redrawTimeline();
						}
					};
				}

				if (this.iconSidebar) {
					var triggerSidebar = function (id) {
						
						if (id === 'treeView') {
							shiftIconLayers = true;
							if (treePane) {
								this$1._initTree({container: treePane, layersTree: layersTree, rawTree: gmxMap.rawTree, gmxTimeline: this$1.gmxTimeline});
							}
						} else {
							shiftIconLayers = false;
							if (treePane) {
								treePane.innerHTML = '';
							}
						}
						if (this$1.IconLayersContainer) {
							this$1.IconLayersContainer.classList[shiftIconLayers ? 'add' : 'remove']('shiftIconLayers');
						}
						if (repaintTimeline) {
							repaintTimeline();
						}
					};
					this.iconSidebar.on('change', function (e) { return triggerSidebar(e.detail.current); });
				}

				var bLayersConf = state.baseLayersManager || { activeIDs: gmxMap.properties.BaseLayers };
				this._initBaseLayers(map, bLayersConf, app);
			}.bind(this))
			.catch(console.log);
			this.set({map: map, config: it});
		},
		_initBaseLayers: function _initBaseLayers(map, baseLayers, app) {
			var lang = 'rus';
			var blm = map.gmxBaseLayersManager,
				activeIDs = baseLayers.activeIDs || ['sputnik'],
				currentID = baseLayers.currentID || activeIDs[0];
			blm.initDefaults().then(function() {
				blm.setActiveIDs(activeIDs);
				var layers = blm.getActiveIDs().map(function (id) {
					var layer = blm.get(id);
					if (!layer) {
						return null;
					} else {
						return {
							layer: layer,
							icon: layer.options.icon,
							title: layer.options[lang]
						}
					}
				}).filter(function (e) { return e; });

				if (app.iconLayers && app.iconLayers !== 'false') {
					var baseLayersControl = new iconLayers(layers, {id: 'iconLayers'});
					map.gmxControlsManager.add(baseLayersControl);
					map.addControl(baseLayersControl);
					baseLayersControl.setActiveLayer(blm.get(currentID));
					this.IconLayersContainer = baseLayersControl.getContainer();
				}
				blm.setCurrentID(currentID);
				if (app.treeView === 'opened' && this.iconSidebar) { this.iconSidebar.setCurrent('treeView'); }
			}.bind(this));
		},
		_getNodeIndex: function _getNodeIndex(target) {
			var arr = target.parentNode.children,
				i, len;
			for(i = 0, len = arr.length; i < len; i++) {
				if (arr[i] === target) { break; }
			}
			return i === len ? null : i;
		},

		_initTree: function _initTree(it) {
			var this$1 = this;

			var rawTree = {
				type: 'map',
				content: it.rawTree
			};
			this._treeView = new TreeView({
				appendNode: function (id) {	// TODO: только видимые элементы (слои и папки) баги серверного скрипта
					return;
					/*
					if (this.gmxMap.nodes) {
						let {map} = this.get();
						let mapID = this.mapID,
							layersTree = this.layersTree,
							visible = layersTree.visible || {},
							// mapItem = L.gmx._maps['maps.kosmosnimki.ru'][mapID],
							gmxMap = this.gmxMap,
							layersByID = gmxMap.layersByID;
						L.gmx.gmxMapManager.getMapFolder({
							treeConfig: layersTree,
							mapId: mapID,
							folderId: id
						}).then(function(json) {
							L.gmx.gmxMapManager.iterateNode(json.content, function(node) {
								let props = node.content.properties,
									layerId = props.name;
								if (layerId && layerId in visible && visible[layerId] !== props.visible) {
									props.visible = visible[layerId];
								}
							}, {nodes: gmxMap.nodes});
							gmxMap.addLayersToMap(map);
							this.treePane.innerHTML = '';
							this._initTree({
								container: this.treePane,
								layersTree: this.layersTree,
								rawTree: gmxMap.rawTree
							});

						}.bind(this));
					}
					*/
				},
				target: it.container,
				data: {
					container: it.container,
					layersTree: it.layersTree,
					gmxTimeline: it.gmxTimeline ? true : false,
					rawTree: rawTree
				}
			});

			this._treeView.on('command', function (ev) {
				var ref = this$1.get();
				var map = ref.map;
				var cmd = ev.cmd,
					target = ev.originalEvent ? ev.originalEvent.target : null,
					layersTree = this$1.layersTree,
					gmxMap = this$1.gmxMap,
					node = gmxMap.nodes ? gmxMap.nodes[ev.id] : true,
					gmxLayer = gmxMap.layersByID[ev.id];

				// console.log('Map command', ev, this.layersTree);
				if (gmxLayer) {
					if (cmd === 'fitBounds') {
						var bounds = gmxLayer.getBounds(),
							zoom = map.getBoundsZoom(bounds),
							opt = gmxLayer.options;

						zoom = zoom < opt.minZoom ? opt.minZoom : (zoom > opt.maxZoom ? opt.maxZoom : zoom);
						map.setView(bounds.getCenter(), zoom);
					} else if (cmd === 'toggleNode') {
						var flag = ev.set;
						if (flag) {
							if (!gmxLayer._map) {
								map.addLayer(gmxLayer);
							}
						} else {
							if (gmxLayer._map) {
								map.removeLayer(gmxLayer);
							}
						}
					} else if (cmd === 'toggleVisibility') {
						if (gmxLayer._map) {
							map.removeLayer(gmxLayer);
						} else {
							map.addLayer(gmxLayer);
						}
					} else if (cmd === 'toggleTimeline' && this$1.gmxTimeline) {
						if (target.classList.contains('enabled')) {
							if (!this$1.gmxTimeline._map) {
								map.addControl(this$1.gmxTimeline);
							}
							this$1.gmxTimeline.addLayer(gmxLayer);
						} else {
							this$1.gmxTimeline.removeLayer(gmxLayer);
						}
					} else if (cmd === 'toggleStyle') {
						var num = this$1._getNodeIndex(target.parentNode),
							styles = gmxLayer.getStyles();
						if (target.classList.contains('enabled')) {
							target.classList.remove('enabled');
							styles[num].disabled = true;
						} else {
							target.classList.add('enabled');
							delete styles[num].disabled;
						}
						gmxLayer.setStyles(styles);
					}
				} else {
					if (cmd === 'toggleVisibility' && !node) {
						this$1._treeView.appendNode(ev.id);
					}
				}
			});
		}
	};

	function onstate$1(ref) {
		var changed = ref.changed;
		var current = ref.current;
		var previous = ref.previous;

		if (changed.permalink && current.permalink) {
			this.createMap(current.permalink);
		}
	}
	function create_main_fragment$3(component, ctx) {
		var div, current;

		return {
			c: function c() {
				div = createElement("div");
				div.id = "map";
			},

			m: function m(target, anchor) {
				insert(target, div, anchor);
				current = true;
			},

			p: noop,

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: run,

			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	function Map(options) {
		var this$1 = this;

		init(this, options);
		this._state = assign(data$3(), options.data);
		this._intro = !!options.intro;

		this._handlers.state = [onstate$1];

		onstate$1.call(this, { changed: assignTrue({}, this._state), current: this._state });

		this._fragment = create_main_fragment$3(this, this._state);

		this.root._oncreate.push(function () {
			this$1.fire("update", { changed: assignTrue({}, this$1._state), current: this$1._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Map.prototype, proto);
	assign(Map.prototype, methods$2);

	/* src\Share.html generated by Svelte v2.16.0 */

	function link(ref) {
		var conf = ref.conf;

		return '//www.kosmosnimki.ru/demo/winnie_2.0/?config=' + conf;
	}

	function data$4() {
		return {
			frameWidth: 800,
			frameHeight: 600,
			conf: 'R6UIY',
			title: ''
		}
	}
	function create_main_fragment$4(component, ctx) {
		var div14, div0, text0, text1, div13, div12, div11, div1, span0, text3, a0, i0, a0_href_value, text4, a1, i1, a1_href_value, text5, a2, i2, a2_href_value, text6, div3, div2, input0, text7, a3, i3, text8, div4, text10, div6, div5, input1, text11, span1, text13, input2, text14, span3, text16, span4, a4, text17, a4_href_value, i5, text18, div9, textarea, textarea_value_value, text19, div8, text20, div10, span5, a5, text21, a5_href_value, i6, current;

		var if_block = (ctx.title) && create_if_block$2(component, ctx);

		function change_handler(event) {
			component.set({frameWidth: this.value});
		}

		function change_handler_1(event) {
			component.set({frameHeight: this.value});
		}

		return {
			c: function c() {
				div14 = createElement("div");
				div0 = createElement("div");
				text0 = createText("\r\n\t");
				if (if_block) { if_block.c(); }
				text1 = createText("\r\n\t");
				div13 = createElement("div");
				div12 = createElement("div");
				div11 = createElement("div");
				div1 = createElement("div");
				span0 = createElement("span");
				span0.textContent = "Ссылка на карту:";
				text3 = createText("\r\n\t\t\t\t\t");
				a0 = createElement("a");
				i0 = createElement("i");
				text4 = createText("\r\n\t\t\t\t\t");
				a1 = createElement("a");
				i1 = createElement("i");
				text5 = createText("\r\n\t\t\t\t\t");
				a2 = createElement("a");
				i2 = createElement("i");
				text6 = createText("\r\n\t\t\t\t");
				div3 = createElement("div");
				div2 = createElement("div");
				input0 = createElement("input");
				text7 = createText("\r\n\t\t\t\t\t\t");
				a3 = createElement("a");
				i3 = createElement("i");
				text8 = createText("\r\n\t\t\t\t");
				div4 = createElement("div");
				div4.textContent = "Код для вставки:";
				text10 = createText("\r\n\t\t\t\t");
				div6 = createElement("div");
				div5 = createElement("div");
				input1 = createElement("input");
				text11 = createText("\r\n\t\t\t\t\t\t\t");
				span1 = createElement("span");
				span1.textContent = "x";
				text13 = createText("\r\n\t\t\t\t\t\t\t");
				input2 = createElement("input");
				text14 = createText("\r\n\t\t\t\t\t\t");
				span3 = createElement("span");
				span3.innerHTML = "<span>предпросмотр</span><i class=\"icon-link-ext svelte-nxbuzg\"></i>";
				text16 = createText("\r\n\t\t\t\t\t\t");
				span4 = createElement("span");
				a4 = createElement("a");
				text17 = createText("конструктор приложений");
				i5 = createElement("i");
				text18 = createText("\r\n\t\t\t\t");
				div9 = createElement("div");
				textarea = createElement("textarea");
				text19 = createText("\r\n\t\t\t\t\t");
				div8 = createElement("div");
				div8.innerHTML = "<div class=\"alertWidget ui-widget\"></div>";
				text20 = createText("\r\n\t\t\t\t");
				div10 = createElement("div");
				span5 = createElement("span");
				a5 = createElement("a");
				text21 = createText("предпросмотр");
				i6 = createElement("i");
				div0.className = "arrow svelte-nxbuzg";
				span0.className = "bold svelte-nxbuzg";
				i0.className = "icon-twitter svelte-nxbuzg";
				a0.className = "gmx-link_icon svelte-nxbuzg";
				a0.target = "_blank";
				a0.href = a0_href_value = "//www.twitter.com/share?url=" + ctx.link;
				i1.className = "icon-facebook svelte-nxbuzg";
				a1.className = "gmx-link_icon svelte-nxbuzg";
				a1.target = "_blank";
				a1.href = a1_href_value = "https://www.facebook.com/sharer/sharer.php?u=" + ctx.link;
				i2.className = "icon-vk svelte-nxbuzg";
				a2.className = "gmx-link_icon svelte-nxbuzg";
				a2.target = "_blank";
				a2.href = a2_href_value = "//vkontakte.ru/share.php?url" + ctx.link;
				div1.className = "shareDialog-row shareDialog-title svelte-nxbuzg";
				input0.className = "shareDialog-inputPermalinkUrl svelte-nxbuzg";
				setAttribute(input0, "type", "text");
				input0.readOnly = "readonly";
				input0.value = ctx.link;
				i3.className = "icon-link-ext svelte-nxbuzg";
				i3.title = "открыть в новом окне";
				a3.className = "gmx-link_icon svelte-nxbuzg";
				a3.target = "_blank";
				a3.href = ctx.link;
				div2.className = "gmx-table";
				div3.className = "shareDialog-row svelte-nxbuzg";
				div4.className = "shareDialog-row bold svelte-nxbuzg";
				addListener(input1, "change", change_handler);
				input1.className = " svelte-nxbuzg";
				setAttribute(input1, "type", "number");
				input1.value = ctx.frameWidth;
				span1.className = "shareDialog-resolutionCross";
				addListener(input2, "change", change_handler_1);
				input2.className = " svelte-nxbuzg";
				setAttribute(input2, "type", "number");
				input2.value = ctx.frameHeight;
				span3.className = "shareDialog-validationError hidden svelte-nxbuzg";
				a4.className = "shareDialog-previewLink gmx-link svelte-nxbuzg";
				a4.href = a4_href_value = "" + ctx.link + "&edit=1";
				a4.target = "_blank";
				i5.className = "gmx-icon icon-link-ext svelte-nxbuzg";
				span4.className = "shareDialog-previewLinkCell constrLink shareDialog-validationOk svelte-nxbuzg";
				div5.className = "gmx-table shareDialog-resolutionTable svelte-nxbuzg";
				div6.className = "shareDialog-row svelte-nxbuzg";
				textarea.className = "shareDialog-validationOk svelte-nxbuzg";
				textarea.readOnly = "readonly";
				textarea.value = textarea_value_value = "<iframe src=\"" + ctx.link + "\" width=\"" + ctx.frameWidth + "\" height=\"" + ctx.frameHeight + "\"></iframe>";
				div8.className = "shareDialog-validationErrorView hidden svelte-nxbuzg";
				div9.className = "shareDialog-row svelte-nxbuzg";
				a5.className = "shareDialog-previewLink gmx-link svelte-nxbuzg";
				a5.href = a5_href_value = "//www.kosmosnimki.ru/demo/winnie_2.0/iframePreview.html?width=" + ctx.frameWidth + "&height=" + ctx.frameHeight + "&url=" + ctx.link;
				a5.target = "_blank";
				i6.className = "gmx-icon icon-link-ext svelte-nxbuzg";
				span5.className = "shareDialog-previewLinkCell shareDialog-validationOk svelte-nxbuzg";
				div10.className = "shareDialog-row svelte-nxbuzg";
				div11.className = "shareDialog";
				div12.className = "shareDialogContainer";
				div13.className = "popover-content svelte-nxbuzg";
				div14.className = "share svelte-nxbuzg";
			},

			m: function m(target, anchor) {
				insert(target, div14, anchor);
				append(div14, div0);
				append(div14, text0);
				if (if_block) { if_block.m(div14, null); }
				append(div14, text1);
				append(div14, div13);
				append(div13, div12);
				append(div12, div11);
				append(div11, div1);
				append(div1, span0);
				append(div1, text3);
				append(div1, a0);
				append(a0, i0);
				append(div1, text4);
				append(div1, a1);
				append(a1, i1);
				append(div1, text5);
				append(div1, a2);
				append(a2, i2);
				append(div11, text6);
				append(div11, div3);
				append(div3, div2);
				append(div2, input0);
				append(div2, text7);
				append(div2, a3);
				append(a3, i3);
				append(div11, text8);
				append(div11, div4);
				append(div11, text10);
				append(div11, div6);
				append(div6, div5);
				append(div5, input1);
				append(div5, text11);
				append(div5, span1);
				append(div5, text13);
				append(div5, input2);
				append(div5, text14);
				append(div5, span3);
				append(div5, text16);
				append(div5, span4);
				append(span4, a4);
				append(a4, text17);
				append(span4, i5);
				append(div11, text18);
				append(div11, div9);
				append(div9, textarea);
				append(div9, text19);
				append(div9, div8);
				append(div11, text20);
				append(div11, div10);
				append(div10, span5);
				append(span5, a5);
				append(a5, text21);
				append(span5, i6);
				current = true;
			},

			p: function p(changed, ctx) {
				if (ctx.title) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$2(component, ctx);
						if_block.c();
						if_block.m(div14, text1);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if ((changed.link) && a0_href_value !== (a0_href_value = "//www.twitter.com/share?url=" + ctx.link)) {
					a0.href = a0_href_value;
				}

				if ((changed.link) && a1_href_value !== (a1_href_value = "https://www.facebook.com/sharer/sharer.php?u=" + ctx.link)) {
					a1.href = a1_href_value;
				}

				if ((changed.link) && a2_href_value !== (a2_href_value = "//vkontakte.ru/share.php?url" + ctx.link)) {
					a2.href = a2_href_value;
				}

				if (changed.link) {
					input0.value = ctx.link;
					a3.href = ctx.link;
				}

				if (changed.frameWidth) {
					input1.value = ctx.frameWidth;
				}

				if (changed.frameHeight) {
					input2.value = ctx.frameHeight;
				}

				if ((changed.link) && a4_href_value !== (a4_href_value = "" + ctx.link + "&edit=1")) {
					a4.href = a4_href_value;
				}

				if ((changed.link || changed.frameWidth || changed.frameHeight) && textarea_value_value !== (textarea_value_value = "<iframe src=\"" + ctx.link + "\" width=\"" + ctx.frameWidth + "\" height=\"" + ctx.frameHeight + "\"></iframe>")) {
					textarea.value = textarea_value_value;
				}

				if ((changed.frameWidth || changed.frameHeight || changed.link) && a5_href_value !== (a5_href_value = "//www.kosmosnimki.ru/demo/winnie_2.0/iframePreview.html?width=" + ctx.frameWidth + "&height=" + ctx.frameHeight + "&url=" + ctx.link)) {
					a5.href = a5_href_value;
				}
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: run,

			d: function d(detach) {
				if (detach) {
					detachNode(div14);
				}

				if (if_block) { if_block.d(); }
				removeListener(input1, "change", change_handler);
				removeListener(input2, "change", change_handler_1);
			}
		};
	}

	// (3:1) {#if title}
	function create_if_block$2(component, ctx) {
		var h3, text;

		return {
			c: function c() {
				h3 = createElement("h3");
				text = createText(ctx.title);
				h3.className = "popover-title";
			},

			m: function m(target, anchor) {
				insert(target, h3, anchor);
				append(h3, text);
			},

			p: function p(changed, ctx) {
				if (changed.title) {
					setData(text, ctx.title);
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(h3);
				}
			}
		};
	}

	function Share(options) {
		init(this, options);
		this._state = assign(data$4(), options.data);

		this._recompute({ conf: 1 }, this._state);
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$4(this, this._state);

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}

		this._intro = true;
	}

	assign(Share.prototype, proto);

	Share.prototype._recompute = function _recompute(changed, state) {
		if (changed.conf) {
			if (this._differs(state.link, (state.link = link(state)))) { changed.link = true; }
		}
	};

	/* src\App.html generated by Svelte v2.16.0 */

	var serverBase$1 = window.serverBase || '//maps.kosmosnimki.ru/',
		chkPar = function (key, h1, h2, zn) { return h1[key] || (key in h2 ? h2[key] : zn || true); };
	function data$5() {
		return {
			share: false,
			conf: '',
			urlParams: {},
			dropdownMenu: [
				{ name: 'refresh', title: 'Refresh' },
				{ name: 'link', title: 'Share', checked: false }
			],
			map: null,
			permalink: null
		}
	}
	var methods$3 = {
		checkMe: function checkMe(it, node) {
			var this$1 = this;

			var cmd = it.name,
				json = this.editor.getValue(),
				out = null;
			try {
				out = JSON.parse(json);
			} catch (err) {
				var error = this.editor.getSession().getAnnotations()[0];
				alert('Ошибка в конфигурации:\n строка: ' + error.row + '\n позиция: ' + error.column + '\n сообщение: ' + error.text);
				console.log('error in json: ' , error);
			}
			if (out) {
				if (cmd === 'refresh') {
					this.set({permalink: out});
				} else if (cmd === 'link') {
					var ref = this.get();
					var share = ref.share;
					if (share) {
						node.classList.remove('checked');
						this.set({share: false});
					} else {
						node.classList.add('checked');
						fetch(serverBase$1 + 'TinyReference/Create.ashx', {
							method: 'post',
							headers: {'Content-type': 'application/x-www-form-urlencoded'},
							body: L.gmxUtil.getFormData({WrapStyle: 'None', content: out}),
							mode: 'cors',
							credentials: 'include'
						})
						.then(function (res) { return res.json(); })
						.then(function (json) {
							if (json.Status === 'ok') {
								this$1.set({share: true, conf:json.Result});
							}
						})
						.catch(console.error);
					}
				}
			}
		},
		checkPermalink: function checkPermalink(out) {
			var this$1 = this;

			var ref = this.get();
			var urlParams = ref.urlParams;
			// console.log('?config=7ZSC4  dddddddd', out, urlParams)
			if (out.app) {
				out.app.theme = chkPar('theme', urlParams, out.app, 'dark');		// тема по умолчанию
				out.app.iconSidebar = chkPar('iconSidebar', urlParams, out.app);	// iconSidebar по умолчанию
				out.app.treeView = chkPar('treeView', urlParams, out.app);			// treeView по умолчанию
				out.app.iconLayers = chkPar('iconLayers', urlParams, out.app);		// iconLayers по умолчанию
				out.app.drawing = chkPar('drawing', urlParams, out.app);			// drawing по умолчанию
				//out.app.gmxTimeline = chkPar('gmxTimeline', urlParams, out.app);	// gmxTimeline по умолчанию
				out.app.gmxTimeline = urlParams.gmxTimeline === 'true' || out.app.gmxTimeline || false;	// gmxTimeline по умолчанию false
			}
			this.set({permalink: out});
			// this.set({permalink: out, confStr: JSON.stringify(out, null, 2)});
			if (urlParams.edit) {
				L.gmxUtil.requestLink('//cdnjs.cloudflare.com/ajax/libs/ace/1.4.1/ace.js', {
					// integrity: 'sha256-kCykSp9wgrszaIBZpbagWbvnsHKXo4noDEi6ra6Y43w=',
					// crossorigin: 'anonymous'
				}).then(function () {
					var editor = ace.edit("editor");
					editor.setTheme("ace/theme/monokai");
					// editor.session.setMode("ace/mode/json");
					editor.getSession().setMode("ace/mode/json");

	 // editor.setOptions({
	    // mode: "ace/mode/json",
	    // theme: "ace/theme/monokai",
	    // fontSize: "10pt",
	    // showPrintMargin : false,
	    // enableBasicAutocompletion: true,
	    // enableSnippets: true,
	    // enableLiveAutocompletion: true,
	    // wrap: true,
	    // scrollPastEnd: true,
	    // displayIndentGuides: true,
	  // });
					// editor.session.setMode("ace/mode/javascript");
					editor.container.getElementsByClassName('ace_scrollbar-v')[0].style.width = '4px';
					editor.setValue(JSON.stringify(out, null, 2));
					this$1.editor = editor;
					// window.ted = editor;
				}).catch(console.warn);

			}
			if (out.app.gmxTimeline && out.app.gmxTimeline !== 'false') {
				L.gmxUtil.requestLink('//maps.kosmosnimki.ru/api/plugins/timeline/2.9.1/timeline.js');
				L.gmxUtil.requestLink('//maps.kosmosnimki.ru/api/plugins/timeline/2.9.1/timeline.css');
				// L.gmxUtil.requestLink('L.Control.gmxTimeLine.js');
				L.gmxUtil.requestLink('//maps.kosmosnimki.ru/api/plugins/external/GMXPluginTimeLine/L.Control.gmxTimeLine.js');
				L.gmxUtil.requestLink('//maps.kosmosnimki.ru/api/plugins/external/GMXPluginTimeLine/L.Control.gmxTimeLine.css');
			}
		},
		getPermalink: function getPermalink(id) {
			var this$1 = this;

			var out = {};
			if (id) {
				fetch(serverBase$1 + 'TinyReference/Get.ashx?WrapStyle=None&id=' + id, {
					mode: 'cors',
					credentials: 'include'
				})
				.then(function (res) { return res.json(); })
				.then(function (json) {
					if (json.Status === 'ok') {
						out = json.Result ? JSON.parse(json.Result) : {};
					}
					this$1.checkPermalink(out);
				});
					// .catch(err => console.log(err));
			// } else {
				// setTimeout(function() {
					// this.checkPermalink(out);
				// }.bind(this), 0);
			}
		}
	};

	function onstate$2(ref) {
		var changed = ref.changed;
		var current = ref.current;
		var previous = ref.previous;

		// console.log('in onstate', changed, current, previous);
		if (changed.urlParams) {
			var conf = current.urlParams.config || 'M6QMS';
			this.getPermalink(conf);
		}
	}
	function click_handler(event) {
		var ref = this._svelte;
		var component = ref.component;
		var ctx = ref.ctx;

		component.checkMe(ctx.it, this);
	}

	function get_each_context$1(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.it = list[i];
		return child_ctx;
	}

	function create_main_fragment$5(component, ctx) {
		var text0, div, map_updating = {}, text1, text2, if_block2_anchor, current;

		var if_block0 = (ctx.urlParams.edit) && create_if_block_2$1(component, ctx);

		var map_initial_data = { permalink: ctx.permalink };
		if (ctx.map  !== void 0) {
			map_initial_data.map = ctx.map ;
			map_updating.map = true;
		}
		var map = new Map({
			root: component.root,
			store: component.store,
			data: map_initial_data,
			_bind: function _bind(changed, childState) {
				var newState = {};
				if (!map_updating.map && changed.map) {
					newState.map = childState.map;
				}
				component._set(newState);
				map_updating = {};
			}
		});

		component.root._beforecreate.push(function () {
			map._bind({ map: 1 }, map.get());
		});

		var if_block1 = (ctx.share) && create_if_block_1$1(component, ctx);

		var if_block2 = (ctx.permalink && ctx.permalink.app && ctx.permalink.app.gmxTimeline) && create_if_block$3(component, ctx);

		return {
			c: function c() {
				if (if_block0) { if_block0.c(); }
				text0 = createText("\r\n");
				div = createElement("div");
				map._fragment.c();
				text1 = createText("\r\n");
				if (if_block1) { if_block1.c(); }
				text2 = createText("\r\n\r\n");
				if (if_block2) { if_block2.c(); }
				if_block2_anchor = createComment();
				div.className = "editor-viewerContainer editor_sidebarExpanded svelte-oqxl1y";
			},

			m: function m(target, anchor) {
				if (if_block0) { if_block0.m(target, anchor); }
				insert(target, text0, anchor);
				insert(target, div, anchor);
				map._mount(div, null);
				insert(target, text1, anchor);
				if (if_block1) { if_block1.m(target, anchor); }
				insert(target, text2, anchor);
				if (if_block2) { if_block2.m(target, anchor); }
				insert(target, if_block2_anchor, anchor);
				current = true;
			},

			p: function p(changed, _ctx) {
				ctx = _ctx;
				if (ctx.urlParams.edit) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_2$1(component, ctx);
						if_block0.c();
						if_block0.m(text0.parentNode, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				var map_changes = {};
				if (changed.permalink) { map_changes.permalink = ctx.permalink; }
				if (!map_updating.map && changed.map) {
					map_changes.map = ctx.map ;
					map_updating.map = ctx.map  !== void 0;
				}
				map._set(map_changes);
				map_updating = {};

				if (ctx.share) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_1$1(component, ctx);
						if (if_block1) { if_block1.c(); }
					}

					if_block1.i(text2.parentNode, text2);
				} else if (if_block1) {
					if_block1.o(function() {
						if_block1.d(1);
						if_block1 = null;
					});
				}

				if (ctx.permalink && ctx.permalink.app && ctx.permalink.app.gmxTimeline) {
					if (!if_block2) {
						if_block2 = create_if_block$3(component, ctx);
						if_block2.c();
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				outrocallback = callAfter(outrocallback, 2);

				if (map) { map._fragment.o(outrocallback); }

				if (if_block1) { if_block1.o(outrocallback); }
				else { outrocallback(); }

				current = false;
			},

			d: function d(detach) {
				if (if_block0) { if_block0.d(detach); }
				if (detach) {
					detachNode(text0);
					detachNode(div);
				}

				map.destroy();
				if (detach) {
					detachNode(text1);
				}

				if (if_block1) { if_block1.d(detach); }
				if (detach) {
					detachNode(text2);
				}

				if (if_block2) { if_block2.d(detach); }
				if (detach) {
					detachNode(if_block2_anchor);
				}
			}
		};
	}

	// (1:0) {#if urlParams.edit}
	function create_if_block_2$1(component, ctx) {
		var div4, div3, div1, div0, text, div2;

		var each_value = ctx.dropdownMenu;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1(component, get_each_context$1(ctx, each_value, i));
		}

		return {
			c: function c() {
				div4 = createElement("div");
				div3 = createElement("div");
				div1 = createElement("div");
				div0 = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text = createText("\r\n\t\t\t");
				div2 = createElement("div");
				div0.className = "dropdownMenuWidget svelte-oqxl1y";
				div1.className = "sidebarPanel-toolbarContainer svelte-oqxl1y";
				div2.id = "editor";
				div2.className = "editor svelte-oqxl1y";
				div3.className = "sidebarPanel svelte-oqxl1y";
				div4.className = "editor-sidebarContainer editor_sidebarExpanded svelte-oqxl1y";
			},

			m: function m(target, anchor) {
				insert(target, div4, anchor);
				append(div4, div3);
				append(div3, div1);
				append(div1, div0);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(div0, null);
				}

				append(div3, text);
				append(div3, div2);
			},

			p: function p(changed, ctx) {
				if (changed.dropdownMenu) {
					each_value = ctx.dropdownMenu;

					for (var i = 0; i < each_value.length; i += 1) {
						var child_ctx = get_each_context$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$1(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div0, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(div4);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (6:0) {#each dropdownMenu as it}
	function create_each_block$1(component, ctx) {
		var div, i, i_class_value, text0, span, text1_value = ctx.it.title, text1, div_class_value;

		return {
			c: function c() {
				div = createElement("div");
				i = createElement("i");
				text0 = createText("\r\n\t\t\t\t\t");
				span = createElement("span");
				text1 = createText(text1_value);
				i.className = i_class_value = "icon-" + ctx.it.name + " svelte-oqxl1y";

				div._svelte = { component: component, ctx: ctx };

				addListener(div, "click", click_handler);
				div.className = div_class_value = "dropdownMenuWidget-item" + (ctx.it.checked ? ' checked' : '') + " svelte-oqxl1y";
			},

			m: function m(target, anchor) {
				insert(target, div, anchor);
				append(div, i);
				append(div, text0);
				append(div, span);
				append(span, text1);
			},

			p: function p(changed, _ctx) {
				ctx = _ctx;
				if ((changed.dropdownMenu) && i_class_value !== (i_class_value = "icon-" + ctx.it.name + " svelte-oqxl1y")) {
					i.className = i_class_value;
				}

				if ((changed.dropdownMenu) && text1_value !== (text1_value = ctx.it.title)) {
					setData(text1, text1_value);
				}

				div._svelte.ctx = ctx;
				if ((changed.dropdownMenu) && div_class_value !== (div_class_value = "dropdownMenuWidget-item" + (ctx.it.checked ? ' checked' : '') + " svelte-oqxl1y")) {
					div.className = div_class_value;
				}
			},

			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(div, "click", click_handler);
			}
		};
	}

	// (21:0) {#if share}
	function create_if_block_1$1(component, ctx) {
		var current;

		var share_initial_data = { conf: ctx.conf };
		var share = new Share({
			root: component.root,
			store: component.store,
			data: share_initial_data
		});

		return {
			c: function c() {
				share._fragment.c();
			},

			m: function m(target, anchor) {
				share._mount(target, anchor);
				current = true;
			},

			p: function p(changed, ctx) {
				var share_changes = {};
				if (changed.conf) { share_changes.conf = ctx.conf; }
				share._set(share_changes);
			},

			i: function i(target, anchor) {
				if (current) { return; }

				this.m(target, anchor);
			},

			o: function o(outrocallback) {
				if (!current) { return; }

				if (share) { share._fragment.o(outrocallback); }
				current = false;
			},

			d: function d(detach) {
				share.destroy(detach);
			}
		};
	}

	// (25:0) {#if permalink && permalink.app && permalink.app.gmxTimeline}
	function create_if_block$3(component, ctx) {
		var svg, defs, clippath, rect, symbol, title, text, path;

		return {
			c: function c() {
				svg = createSvgElement("svg");
				defs = createSvgElement("defs");
				clippath = createSvgElement("clippath");
				rect = createSvgElement("rect");
				symbol = createSvgElement("symbol");
				title = createSvgElement("title");
				text = createText("gmxTimeline");
				path = createSvgElement("path");
				setAttribute(rect, "x", "0");
				setAttribute(rect, "y", "0");
				setAttribute(rect, "width", "13");
				setAttribute(rect, "height", "13");
				setAttribute(clippath, "id", "clip-path");
				setAttribute(path, "d", "M6.5,0C2.9,0,0,2.9,0,6.5S2.9,13,6.5,13S13,10.1,13,6.5S10.1,0,6.5,0z M9.8,7.3H5.7V3.3h1.6v2.4h2.4V7.3z");
				setAttribute(symbol, "id", "timeline-icon");
				setAttribute(symbol, "viewBox", "0 0 13 13");
				setAttribute(svg, "xmlns", "http://www.w3.org/2000/svg");
				setStyle(svg, "display", "none");
			},

			m: function m(target, anchor) {
				insert(target, svg, anchor);
				append(svg, defs);
				append(defs, clippath);
				append(clippath, rect);
				append(svg, symbol);
				append(symbol, title);
				append(title, text);
				append(symbol, path);
			},

			d: function d(detach) {
				if (detach) {
					detachNode(svg);
				}
			}
		};
	}

	function App(options) {
		var this$1 = this;

		init(this, options);
		this._state = assign(data$5(), options.data);
		this._intro = !!options.intro;

		this._handlers.state = [onstate$2];

		onstate$2.call(this, { changed: assignTrue({}, this._state), current: this._state });

		this._fragment = create_main_fragment$5(this, this._state);

		this.root._oncreate.push(function () {
			this$1.fire("update", { changed: assignTrue({}, this$1._state), current: this$1._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(App.prototype, proto);
	assign(App.prototype, methods$3);

	var pars = (function () {
		var p = {};
		location.search.substr(1).split('&').forEach(function (it) {
			var arr = it.split('=');
			p[arr[0]] = arr[1];
		});
		return p;
	})();

	var app = new App({
		target: document.body,
		//target: document.getElementsByClassName('editor-sidebarContainer')[0] || document.body,
		data: {
			urlParams: pars,
			name: 'world'
		}
	});

	return app;

}(L));
//# sourceMappingURL=winnie_2.0.js.map
